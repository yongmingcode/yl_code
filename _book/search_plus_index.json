{"./":{"url":"./","title":"介绍","keywords":"","body":"博客地址 技术博客——满月弓 【Gitbook】技术博客——满月弓 简 介 这是一个个人技术分享的网站。站中内容主要来源于博客、书籍以及笔者平时工作学习中知识点的总结。 以前自己的知识点都分门别类的记录在印象笔记和自己的个人主页，但最近服务器和域名都从百度云迁移了，而印象笔记更多的是自己使用，分享不便。我又发现，这是一个重新整理心中知识的机会，所以开启了这个技术分享的站点。 笔者一直认为，一件事物的兴盛，离不开无数贡献者的默默奉献。而知识，只有分享才会更有价值。笔者也愿意作为一名默默的贡献者，希望通过奉献自己的点点萤火，让知识传播与分享这把火燃的更旺！ 本站期望 志向立高远，学问做精细； 好记性不如烂笔头，站点中每个知识点我都会亲手操作，希望你也一样哦； 不积跬步，无以至千里，积累是人类永远谈不完的话题； 蚊子再小也是肉，记录的知识点不分主次，都需要认真咀嚼。 勘误与支持 由于笔者技术有限，编写时间仓促，文章中难免出现一些错误或者不准确的地方，恳请读者批评指正。如果您有更多的宝贵意见，可以再我的github上新建issue，笔者会尽快解答，期待得到您的真挚反馈。github地址： https://github.com/yongmingcode/yl_code "},"java/java.html":{"url":"java/java.html","title":"Java","keywords":"","body":"JDK源码解读 本节会对项目开发中的知识点进行总结以及对jdk中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 "},"java/util/util.html":{"url":"java/util/util.html","title":"util","keywords":"","body":"util jdk提供的工具类目录，存在于rt.jar包中。 rt.jar代表runtime JAR,包含引导类bootstrap classes，包含所有核心JavaJava基础类运行环境的已编译calss文件，更多相关请看： Java / JDK / JRE中的rt.jar是什么？ 为什么重要？ "},"java/util/collections.html":{"url":"java/util/collections.html","title":"collections","keywords":"","body":"collections 这个类包含对集合进行操作的静态方法。 "},"java/util/shuffle.html":{"url":"java/util/shuffle.html","title":"shuffle方法解读","keywords":"","body":"伊始 有这么一个场景：有一个抽奖活动，需要对几种奖品随机发放。我们可以将不同的奖品类别放入List，然后调用shuffle方法打乱这个List中元素的顺序，然后get(0),即可获得随机的一个奖品。 ArrayList integerList = new ArrayList<>(); integerList.add(0); integerList.add(1); integerList.add(2); Collections.shuffle(integerList); // 控制台可能打印0、1、2中的任何一个 System.out.println(integerList.get(0)); 方法作用： shuffle(List list)：使用默认的随机源，随机排列指定的列表。所有排列将以近似相等的可能性发生。 shuffle(List list, Random rnd)：使用指定的随机源，随机排列指定的列表。假设随机性的来源是公平的，那么所有排列都会以相同的可能性发生。 方法原理 以下是jdk源码（1.8）： public static void shuffle(List list, Random rnd) { int size = list.size(); if (size 1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i>1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i 上面代码先判断list的size是否小于SHUFFLE_THRESHOLD(5)或者实现RandomAccess接口，如果符合条件，则执行swap(List list, int i, int j)方法进行交换；如果不符合条件，则把list转为数组，数组执行swap(Object[] arr, int i, int j)（注意这里是另外一个swap()方法哦）方法进行交换，交换之后的数组循环转回List。 到这里我产生了几个疑问： 那判断条件为什么是size是否小于SHUFFLE_THRESHOLD(5)和实现RandomAccess接口？ 为什么符合条件就直接交换？不符合条件就转为数组再交换？ 这几个问题留在后面解答。 我们来看一下这两个swap()方法： swap(Object[] arr, int i, int j) private static void swap(Object[] arr, int i, int j) { Object tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } 有三个参数： list：要交换元素的list。 i、j: 是两个要交换元素的下标 i: shuffle()方法中是从list的最后一个下标开始 j：列表中随机的一个下标 然后让i、j下标的元素进行交换。 swap(List list, int i, int j)方法： public static void swap(List list, int i, int j) { // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method final List l = list; l.set(i, l.set(j, l.get(i))); } i、j参数的含义和上面的swap(Object[] arr, int i, int j)方法含义相同，方法的功能也是简单的让i、j下标的元素进行交换。 但是swap(List list, int i, int j)方法中有一个需要注意的地方：final List l = list，这里为什么不直接用list，而是通过使用副本 l 进行操作呢？使用中间变量（副本）是为了规避泛型的缺点!不理解可以参考文末的参考文档。 参考资料： 爲什麼Collections.swap複製輸入列表？ 为什么Collections.swap将目标列表分配给原始类型的变量？ Java 泛型，你了解类型擦除吗？ "},"java/knacks/knacks.html":{"url":"java/knacks/knacks.html","title":"技巧","keywords":"","body":"介绍 这里笔者会着重介绍一下日常开发代码中比较有意思的优化。 "},"java/knacks/if_else_decoupling.html":{"url":"java/knacks/if_else_decoupling.html","title":"if...else...解耦","keywords":"","body":"if...else...解耦 在spring的初始化bean中讲到，过深的if...else...条件判断使得代码变得可读性差、不易维护。 本文通过静态工厂+策略模式对if...else...实现解耦。 1.以初始化bean中发奖为例，首先定义一个接口： /** * @description: 发放奖励 * @author: yongmingcode */ public interface IHandOutPrize { void doHandOut(); } 2.定义发放现金奖励类： /** * @description: 发放现金奖励 * @author: yongmingcode */ @Service public class HandOutCash implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\" -------HandOutCash doHandOut-------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"cash\", this); } } 3.定义发放积分奖励类： /** * @description: 发放积分奖励 * @author: yongmingcode */ @Service public class HandOutPoint implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\"-------------HandOutPoint doHandOut -----------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"point\", this); } } 4.定义发放奖品的静态工厂类： /** * @description: 发放奖品的静态工厂 * @author: yongmingcode */ public class HandOutPrizeFactory { private static Map handOutPrizeMap = new HashMap(); public HandOutPrizeFactory() { } private static IHandOutPrize EMPTY = new EmptyHandOutPrize(); /** 注册 */ public static void registerHandOutPrize(String prizeType, IHandOutPrize handOutPrize){ handOutPrizeMap.put(prizeType, handOutPrize); } /** 获取 */ public static IHandOutPrize getHandOutPrize(String prizeType){ IHandOutPrize handOutPrize = handOutPrizeMap.get(prizeType); return handOutPrize == null ? EMPTY : handOutPrize; } private static class EmptyHandOutPrize implements IHandOutPrize{ public void doHandOut() { System.out.println(\" EmptyHandOutPrize \"); } } } 5.最后，写一个发放现金奖励类： /** * @description: if...else...解耦 * @author: yongmingcode */ public class IfElseDecoupling { public static void main(String[] args){ // 发放现金奖励 handOutPrize(\"cash\"); } private static void handOutPrize(String prizeType){ IHandOutPrize handOutPrize = HandOutPrizeFactory.getHandOutPrize(prizeType); handOutPrize.doHandOut(); } } 上面代码的解释： 定义了一个发放奖励的IHandOutPrize接口，该接口只有一个发放奖励的方法； HandOutCash、HandOutPoint是IHandOutPrize接口的两个实现类，同时实现了InitializingBean接口（该接口关介绍请移驾bean的初始化方法），并在afterPropertiesSet()方法中对当前类进行了注册； 通过静态工厂HandOutPrizeFactory类进行奖励的注册和获取； 在IfElseDecoupling类中进行发放奖励，如发放现金奖励只需要两行代码就够了。 总结： 优点：以上对if...else...形式代码进行了解耦重构，重构后的逻辑清晰、明了，如果新增一种奖品，只需要定义一个新的类即可，这样大大提高了代码的可读性和可维护性。 缺点：会增加很多类。 参考资料： 代码重构：用工厂+策略模式优化过多的if else代码块 我的Java设计模式-策略模式 Spring核心接口之InitializingBean "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Spring源码解读 本节会对spring中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 "},"spring/bean/bean.html":{"url":"spring/bean/bean.html","title":"初始化bean","keywords":"","body":"伊始 五一、双十一、双十二之类的活动，常常需要根据用户获得的奖品，做不同的处理，这样代码中很可能就会有不少的判断。 比如活动中的奖品有：现金、积分、优惠券、BD奖品等，如果用户获得现金，我们就要做现金的逻辑处理，如果获得积分就做积分逻辑的处理。我们可能会这么做： if(\"cash\".equals(prize)){ System.out.println(\"给用户发现金！\"); }else if(\"points\".equals(prize)){ System.out.println(\"给用户发积分！\"); }else if(\"coupons\".equals(prize)){ System.out.println(\"给用户发优惠券！\"); }else if(\"aiqiyi\".equals(prize)){ System.out.println(\"给用户发爱奇艺会员！\"); } 如果奖品很多，就进行很多个判断。不难发现，这样的代码可读性差、不易维护。我们可以使用策略模式优化它，优化demo会在后面的文章中更新。 这里可以通过org.springframework.beans.factory.InitializingBean接口来实现。而InitializingBean接口就是spring中bean的初始化方法之一。 "},"spring/bean/bean_initialization_method.html":{"url":"spring/bean/bean_initialization_method.html","title":"bean的初始换方法","keywords":"","body":"bean的初始换方法 Spring的Bean在初始化完成后及销毁之前，允许程序执行特定的操作。有一下三种方式定指定： 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 通过下面代码来验证： 配置文件spring-context.xml： 测试类： package com.init; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; /** * @author: yongmingcode * @create: 2020-04-22 17:43 */ public class TestInitializationBean implements InitializingBean, DisposableBean { public TestInitializationBean() { System.out.println(\"----------------------TestInitializationBean 构造方法执行------------------\"); } /** 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 */ public void afterPropertiesSet() throws Exception { System.out.println(\"TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行\"); } public void destroy() throws Exception { System.out.println(\"TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行\"); } /** 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 */ public void initMethod(){ System.out.println(\"TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行\"); } public void destroyMethod(){ System.out.println(\"TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行\"); } /** 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 */ @PostConstruct public void postConstruct(){ System.out.println(\"TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行\"); } @PreDestroy public void preDestroy(){ System.out.println(\"TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行\"); } public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\"); System.out.println(\"------------------------初始化完成------------------------------\"); context.close(); System.out.println(\"------------------------销毁完成------------------------------\"); } } 执行后控制台输出： 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.getSingleton()] DEBUG - Creating shared instance of singleton bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Creating instance of bean 'initAndDestroySeqBean' ----------------------TestInitializationBean 构造方法执行------------------ 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found init method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.postConstruct() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found destroy method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.preDestroy() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered init method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1ab9f17 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered destroy method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doCreateBean()] DEBUG - Eagerly caching bean 'initAndDestroySeqBean' to allow for resolving potential circular references 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeInitMethods()] DEBUG - Invoking init method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.postConstruct() TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeInitMethods()] DEBUG - Invoking afterPropertiesSet() on bean with name 'initAndDestroySeqBean' TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeCustomInitMethod()] DEBUG - Invoking init method 'initMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Finished creating instance of bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.initLifecycleProcessor()] DEBUG - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1ef3efa8] 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [PropertySourcesPropertyResolver.getProperty()] DEBUG - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source ------------------------初始化完成------------------------------ 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.doClose()] INFO - Closing org.springframework.context.support.ClassPathXmlApplicationContext@41f69e84: startup date [Wed Apr 22 18:06:25 CST 2020]; root of context hierarchy 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.destroySingletons()] DEBUG - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19b93fa8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,initAndDestroySeqBean]; root of factory hierarchy 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeDestroyMethods()] DEBUG - Invoking destroy method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.preDestroy() TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.destroy()] DEBUG - Invoking destroy() on bean with name 'initAndDestroySeqBean' TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.invokeCustomDestroyMethod()] DEBUG - Invoking destroy method 'destroyMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行 ------------------------销毁完成------------------------------ Disconnected from the target VM, address: '127.0.0.1:61729', transport: 'socket' 从执行结果可以看出： Bean在实例化的过程中：Constructor > @PostConstruct >InitializingBean > init-method Bean在销毁的过程中：@PreDestroy > DisposableBean > destroy-method 参考资料： Spring容器中的Bean几种初始化方法和销毁方法的先后顺序 spring的Bean初始化方法的2种方式 "}}