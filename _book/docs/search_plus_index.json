{"./":{"url":"./","title":"介绍","keywords":"","body":"简介 这是一个笔者个人技术分享的网站。专注记录一些平时工作学习中知识点的总结。 以前自己的知识点都分门别类的记录在印象笔记和自己的个人主页，但最近服务器和域名都从百度云迁移了，而印象笔记更多的是自己使用，分享不便...balabala...所以抽空整了个技术分享的站点。 本站期望 志向立高远，学问做精细； 好记性不如烂笔头，站点中每个知识点我都会亲手操作，希望你也一样哦； 不积跬步无以至千里，记录的知识点不分主次，蚊子再小也是肉，都需要认真咀嚼。 "},"java/java.html":{"url":"java/java.html","title":"Java相关","keywords":"","body":"JDK源码解读 本节会对项目开发中的知识点进行总结以及对jdk中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 "},"java/knacks/knacks.html":{"url":"java/knacks/knacks.html","title":"技巧","keywords":"","body":"介绍 这里笔者会着重介绍一下日常开发代码中比较有意思的优化。 "},"java/knacks/if_else_decoupling.html":{"url":"java/knacks/if_else_decoupling.html","title":"if...else...解耦","keywords":"","body":"if...else...解耦 在spring的初始化bean中讲到，过深的if...else...条件判断使得代码变得可读性差、不易维护。 本文通过静态工厂+策略模式对if...else...实现解耦。 以初始化bean中发奖为例，首先定义一个接口： /** * @description: 发放奖励 * @author: yongmingcode */ public interface IHandOutPrize { void doHandOut(); } 定义发放现金奖励类： /** * @description: 发放现金奖励 * @author: yongmingcode */ @Service public class HandOutCash implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\" -------HandOutCash doHandOut-------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"cash\", this); } } 定义发放积分奖励类： /** * @description: 发放积分奖励 * @author: yongmingcode * @create: 2020-04-23 11:49 */ @Service public class HandOutPoint implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\"-------------HandOutPoint doHandOut -----------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"point\", this); } } 定义发放奖品的静态工厂类： /** * @description: 发放奖品的静态工厂 * @author: yongmingcode */ public class HandOutPrizeFactory { private static Map handOutPrizeMap = new HashMap(); public HandOutPrizeFactory() { } private static IHandOutPrize EMPTY = new EmptyHandOutPrize(); /** 注册 */ public static void registerHandOutPrize(String prizeType, IHandOutPrize handOutPrize){ handOutPrizeMap.put(prizeType, handOutPrize); } /** 获取 */ public static IHandOutPrize getHandOutPrize(String prizeType){ IHandOutPrize handOutPrize = handOutPrizeMap.get(prizeType); return handOutPrize == null ? EMPTY : handOutPrize; } private static class EmptyHandOutPrize implements IHandOutPrize{ public void doHandOut() { System.out.println(\" EmptyHandOutPrize \"); } } } 最后，写一个发放现金奖励类： /** * @description: if...else...解耦 * @author: yongmingcode */ public class IfElseDecoupling { public static void main(String[] args){ // 发放现金奖励 handOutPrize(\"cash\"); } private static void handOutPrize(String prizeType){ IHandOutPrize handOutPrize = HandOutPrizeFactory.getHandOutPrize(prizeType); handOutPrize.doHandOut(); } } 上面代码的总结： 定义了一个发放奖励的IHandOutPrize接口，该接口只有一个发放奖励的方法； HandOutCash、HandOutPoint是IHandOutPrize接口的两个实现类，同时实现了InitializingBean接口（该接口关介绍请移驾bean的初始化方法），并在afterPropertiesSet()方法中对当前类进行了注册； 通过静态工厂HandOutPrizeFactory类进行奖励的注册和获取； 在IfElseDecoupling类中进行发放奖励，如发放现金奖励只需要两行代码就够了。 "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring相关","keywords":"","body":"Spring源码解读 本节会对spring中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 "},"spring/bean/bean.html":{"url":"spring/bean/bean.html","title":"初始化bean","keywords":"","body":"伊始 五一、双十一、双十二之类的活动，常常需要根据用户获得的奖品，做不同的处理，这样代码中很可能就会有不少的判断。 比如活动中的奖品有：现金、积分、优惠券、BD奖品等，如果用户获得现金，我们就要做现金的逻辑处理，如果获得积分就做积分逻辑的处理。我们可能会这么做： if(\"cash\".equals(prize)){ System.out.println(\"给用户发现金！\"); }else if(\"points\".equals(prize)){ System.out.println(\"给用户发积分！\"); }else if(\"coupons\".equals(prize)){ System.out.println(\"给用户发优惠券！\"); }else if(\"aiqiyi\".equals(prize)){ System.out.println(\"给用户发爱奇艺会员！\"); } 如果奖品很多，就进行很多个判断。不难发现，这样的代码可读性差、不易维护。我们可以使用策略模式优化它，优化demo会在后面的文章中更新。 这里可以通过org.springframework.beans.factory.InitializingBean接口来实现。而InitializingBean接口就是spring中bean的初始化方法之一。 "},"spring/bean/bean_initialization_method.html":{"url":"spring/bean/bean_initialization_method.html","title":"bean的初始换方法","keywords":"","body":"bean的初始换方法 Spring的Bean在初始化完成后及销毁之前，允许程序执行特定的操作。有一下三种方式定指定： 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 通过下面代码来验证： 配置文件spring-context.xml： 测试类： package com.init; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; /** * @author: yongmingcode * @create: 2020-04-22 17:43 */ public class TestInitializationBean implements InitializingBean, DisposableBean { public TestInitializationBean() { System.out.println(\"----------------------TestInitializationBean 构造方法执行------------------\"); } /** 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 */ public void afterPropertiesSet() throws Exception { System.out.println(\"TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行\"); } public void destroy() throws Exception { System.out.println(\"TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行\"); } /** 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 */ public void initMethod(){ System.out.println(\"TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行\"); } public void destroyMethod(){ System.out.println(\"TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行\"); } /** 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 */ @PostConstruct public void postConstruct(){ System.out.println(\"TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行\"); } @PreDestroy public void preDestroy(){ System.out.println(\"TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行\"); } public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\"); System.out.println(\"------------------------初始化完成------------------------------\"); context.close(); System.out.println(\"------------------------销毁完成------------------------------\"); } } 执行后控制台输出： 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.getSingleton()] DEBUG - Creating shared instance of singleton bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Creating instance of bean 'initAndDestroySeqBean' ----------------------TestInitializationBean 构造方法执行------------------ 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found init method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.postConstruct() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found destroy method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.preDestroy() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered init method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1ab9f17 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered destroy method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doCreateBean()] DEBUG - Eagerly caching bean 'initAndDestroySeqBean' to allow for resolving potential circular references 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeInitMethods()] DEBUG - Invoking init method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.postConstruct() TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeInitMethods()] DEBUG - Invoking afterPropertiesSet() on bean with name 'initAndDestroySeqBean' TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeCustomInitMethod()] DEBUG - Invoking init method 'initMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Finished creating instance of bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.initLifecycleProcessor()] DEBUG - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1ef3efa8] 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [PropertySourcesPropertyResolver.getProperty()] DEBUG - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source ------------------------初始化完成------------------------------ 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.doClose()] INFO - Closing org.springframework.context.support.ClassPathXmlApplicationContext@41f69e84: startup date [Wed Apr 22 18:06:25 CST 2020]; root of context hierarchy 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.destroySingletons()] DEBUG - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19b93fa8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,initAndDestroySeqBean]; root of factory hierarchy 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeDestroyMethods()] DEBUG - Invoking destroy method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.preDestroy() TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.destroy()] DEBUG - Invoking destroy() on bean with name 'initAndDestroySeqBean' TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.invokeCustomDestroyMethod()] DEBUG - Invoking destroy method 'destroyMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行 ------------------------销毁完成------------------------------ Disconnected from the target VM, address: '127.0.0.1:61729', transport: 'socket' 从执行结果可以看出： Bean在实例化的过程中：Constructor > @PostConstruct >InitializingBean > init-method Bean在销毁的过程中：@PreDestroy > DisposableBean > destroy-method 参考资料： Spring容器中的Bean几种初始化方法和销毁方法的先后顺序 "}}