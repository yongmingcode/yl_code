{"./":{"url":"./","title":"介绍","keywords":"","body":"博客地址 技术博客——满月弓 【Gitbook】技术博客——满月弓 简 介 这是一个个人技术分享的网站。站中内容主要来源于博客、书籍以及笔者平时工作学习中知识点的总结。 以前自己的知识点都分门别类的记录在印象笔记和自己的个人主页，但最近服务器和域名都从百度云迁移了，而印象笔记更多的是自己使用，分享不便。我又发现，这是一个重新整理心中知识的机会，所以开启了这个技术分享的站点。 笔者一直认为，一件事物的兴盛，离不开无数贡献者的默默奉献。而知识，只有分享才会更有价值。笔者也愿意作为一名默默的贡献者，希望通过奉献自己的点点萤火，让知识传播与分享这把火燃的更旺！ 本站期望 志向立高远，学问做精细； 不积跬步，无以至千里。积累是人类永远谈不完的话题； 蚊子再小也是肉。记录的知识点不分主次，都需要认真咀嚼； 知其然，亦知其所以然。本站中的知识点，知道怎么用，更能知道为什么能这么用。 勘误与支持 由于笔者技术有限，编写时间仓促，文章中难免出现一些错误或者不准确的地方，恳请读者批评指正。如果您有更多的宝贵意见，可以再我的github上新建issue，笔者会尽快解答，期待得到您的真挚反馈。gitbook地址： www.yongmingcode.tech © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:58:19 "},"java/java.html":{"url":"java/java.html","title":"Java","keywords":"","body":"JDK源码解读 本节会对项目开发中的知识点进行总结以及对jdk 1.8中的部分源码进行解读（文中如果未标明jdk版本，那默认就是jdk1.8版本），其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/series.html":{"url":"java/series.html","title":"系列","keywords":"","body":"系列 每个系列定义一组java知识点，方便读者对各个知识点的整体进行把控，站得高，看的远。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/series/collection.html":{"url":"java/series/collection.html","title":"集合","keywords":"","body":"伊始 阳春三月，草长莺飞,我很享受校园风光（比如说情人坡上的美女~），也常常会和小伙伴一起去旁听一些学校比较有意思的公开课。学校的阶梯教室、讲师的尊尊教导，常常会梦里萦绕（谨此怀念过去许久的美好校园时光）。 为了方便操作，我们常常会将同一类型的元素放在一个阶梯教室里，哦，就是放在一起。在java中，可能你马上会想到数组，确实，数组是一个很好的解决方案。 数组有个特点，它的底层实现是在内存中寻找一块连续的座位，然后把具有相同特点的元素放在一起。可是公开课，常常人满为患，我和小伙伴常常找不到一块连续的座位，如果我们非要一块连续的座位，那么很可能就会被告知OOM异常。或许某次我们非常幸运，找到了连着的座位，可是后来又来了几个小伙伴要一起旁听课,为了体现基友情，我们又要重新找连在一起的座位，重新创建数组，这样就很费精力......所以，我们常常分开坐。 为了解决类似上面的问题，java提供了令人非常激动的保存对象工具——集合。集合解决了“在任意时刻，任意位置，创建任意数量对象”的问题。 在本节，我们会去探索java中集合的实现，学习集合的使用，分析涉及的算法，看看用到的设计模式，体会设计者的设计思路。 以下是集合系列文章： I_Iterator I_Iterable I_Collection c_AbstractCollection I_ListIterator I_List c_AbstractList C_ArrayList © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/util.html":{"url":"java/util/util.html","title":"util","keywords":"","body":"util java.util包存在rt.jar包中，该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 jdk提供的工具类目录，存在于rt.jar包中。 rt.jar代表runtime JAR,包含引导类bootstrap classes，包含所有核心JavaJava基础类运行环境的已编译calss文件，更多相关介绍可以参考文末参考资料。 参考资料 Java / JDK / JRE中的rt.jar是什么？ 为什么重要？ 了解java .lang 包,java.util包等常用包 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/c_AbstractCollection.html":{"url":"java/util/c_AbstractCollection.html","title":"c_AbstractCollection","keywords":"","body":"c_AbstractCollection AbstractCollection是唯一一个实现Collection接口的类，并且是一个抽象类。我们可以先看一下它的方法实现，再去分析这个类的作用。 源码分析 常量 MAX_ARRAY_SIZE：要分配的最大数组大小。jdk中定义如下：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造方法 protected AbstractCollection() {} 相关方法： 属性操作 isEmpty()：判断集合是否为空，其标准是集合size()是否等于0。 toArray(): 将集合转为Object类型的数组。 toArray(T[])：将集合转为指定类型的数组。 finishToArray(T[], Iterator)：对集合进行扩容。 hugeCapacity(int)：溢出处理，即最大容量判断处理。 toString()：重写的toString方法。将集合中的元素以[a,b]的形式，使用StringBuilder拼接成字符串。 添加 addAll(Collection): 通过for-each(其实还是迭代器)遍历每一个元素，通过add方法将元素添加到集合中。 删除 remove(Object): 通过迭代器进行遍历寻找要删除的元素，并通过迭代器的remove方法删除元素。 removeAll(Collection): 集合求差集。 迭代器遍历判断参数集合中是否包含目标集合中的元素，如果包含，则删除目标集合中的元素。 修改 retainAll(Collection): 集合求并集。迭代器遍历目标集合，判断只要元素不存在于参数集合中，则将元素从目标集合中移除。 clear()：通过迭代器移除集合中的元素。 查询 contains(Object o)：通过迭代器进行循环判断集合中是否有某个元素，如果有则返回true。 containsAll(Collection): 通过for循环皮判断参数中的元素，让每一个元素通过contains方法进行判断看，只要有一个元素不存在集合中，则返回false。 以上就是AbstractCollection类的讲解，其实着重对toArray方法进行了分析，了解了AbstractCollection类对集合的扩容方式。 总结 AbstractCollection抽象类是Collection接口唯一的实现类，主要对Collection接口进行了最小程度的实现。 抽象类和接口 除了源码分析，我们也可以来看看抽象类和接口这两个概念。 有句很经典的话： 抽象类是对一类事物的抽象，而接口是对一种行为的抽象。 二者设计上的区别 举个例子：比如飞机和鸟是两个不同的类别，但是他们都有一个共性——飞行。那么在设计上，可以将飞机设计为一个类AirPlane,将鸟设计为一个Bird类，但是不能将飞行设计为一个类，因为飞行只是一个行为特性，并不能具体描述某一类事物。既然飞行是行为，那么我们可以将这一行为设计为一个接口Fly,它具有fly方法。然后AirPlane和Bird分别根据需要实现Fly这个接口，再进行各自的实现。至于有不同种类的飞机，比如如果是战斗机、民用飞机等直接继承Airplane即可，这里可以看出，继承是一个“是不是”的关系。而有些鸟是不能飞的，那不用实现Fly这个接口，所以这里可以看出，接口实现是“有没有”的关系。 设计层面上不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？大家都用过ppt里面的模板，如果用模板A设计了ppt B 和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： abstract class Door { public abstract void open(); public abstract void close(); } 或者： interface Door { public abstract void open(); public abstract void close(); } 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出，Door的open()、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。 interface Alram { void alarm(); } abstract class Door { void open(); void close(); } class AlarmDoor extends Door implements Alarm { void oepn() { //.... } void close() { //.... } void alarm() { //.... } } 参考文档： 深入理解Java的接口和抽象类 java提高篇（四）-----抽象类与接口 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/abstractcollection/M_toArray.html":{"url":"java/util/abstractcollection/M_toArray.html","title":"M_toArray","keywords":"","body":"介绍——jdk 1.8 toArray方法分析 在AbstractCollection中重载了2个toArray方法，都是为了将集合转数组。功能上来看，二者最大的区别就是返回的数组类型不同，一个是返回Object[],另一个返回的是指定的类型。但二者的实现过程差别比较大。 toArray(): 源码分析（jdk 1.8）： public Object[] toArray() { // 准备了一个和集合size()大小的数组 Object[] r = new Object[size()]; Iterator it = iterator(); for (int i = 0; i 上面新建了一个数组，将集合中的元素遍历放入数组。代码中对多线程环境下的情况进行了处理，如果有别的线程对集合进行了修改使得：集合元素少于预期，则截断返回;集合元素多于预期，则数组进行扩容添加，然后再返回数组。 如果数组的长度不够，这里调用了finishToArray方法进行扩容： private static T[] finishToArray(T[] r, Iterator it) { int i = r.length; // 1.从集合中多出来的元素（即数组装不下的元素）开始迭代 while (it.hasNext()) { int cap = r.length; // 每次重新获取新数组r中元素的数量，供下面进行对比，保证数组r有容量储存迭代器it中的元素 if (i == cap) { // 2.下面是扩容操作。如果 // 2.1 进行扩容：容量变为原容量的1.5倍，capp + cap/2 + 1 int newCap = cap + (cap >> 1) + 1; // 2.2 判断新容量是否溢出，即超出最大容量 if (newCap - MAX_ARRAY_SIZE > 0) newCap = hugeCapacity(cap + 1); // 2.3 将数组r中的元素放入一个长度为newCap的新数组中 r = Arrays.copyOf(r, newCap); } r[i++] = (T)it.next(); } // trim if overallocated return (i == r.length) ? r : Arrays.copyOf(r, i); } finishToArray方法对数组进行扩容，在数组不会溢出的前提下，即数组长度没有达到最大长度的前提下，保证数组r中有足够的空间存储迭代器it中的元素（采取容量不够就扩容的方式）。 最大容量判断： private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 这里判断了数组溢出的情况，并对溢出的数组给定了最大的长度（如果最大长度也没法满足，那就没办法了）。 int值加1为什么会变成负数？ 计算机存储的数值，都是用补码进行表示。即首位都是符号位，0表示正数，1表示负数。如int是32位，则第一位是符号位，其余的31位进行计算（二进制位运算）。所以最大的int值是： 0111 1111 1111 1111 1111 1111 1111 1111 加1： 1000 0000 0000 0000 0000 0000 0000 0000 符号位是1，所以是负值。 toArray(T[]): public T[] toArray(T[] a) { // 1.预估集合大小 int size = size(); // 2. 准备一个合适的数组存储集合的元素： // 2.1 如果a的长度大于集合的长度，则直接向a中存元素就行，即让r和a指向同一个对象 // 2.2 否则，创建一个与a类型相同且大小相等的数组 T[] r = a.length >= size ? a : (T[])java.lang.reflect.Array .newInstance(a.getClass().getComponentType(), size); Iterator it = iterator(); for (int i = 0; i i) { //a装完集合中的元素还有空余空间 a[i] = null; // 则将剩余的空间置为null } } return a; } r[i] = (T)it.next(); } // 这里考虑了一下多线程情况 // 如果当前集合还有未转入数组的元素，则调用finishToArray方法,进行扩容 // 如果当前集合没有未转入数组的元素，则返回数组r return it.hasNext() ? finishToArray(r, it) : r; } 该方法传入一个指定类型的数组，并返回一个指定类型的数组。 通过上面的代码分析不难看出，使用该方法，最好是传入一个与集合长度相同的数组，不然会产生资源浪费： 传入的数组空间不够，则toArray方法内部会创建一个新的数组，重新分配内存空间； 传入的数组空间过大，多出来的空间被置为null，造成资源浪费。 所以我们可以这样使用: List list = new ArrayList<>(2); list.add(\"guan\"); list.add(\"bao\"); String[] array = new String[list.size()]; array = list.toArray(array); 总结 通过上面的分析，对于集合转数组，我们得出以下结论： 无参的toArray方法，只能返回Object[]类型的数组，其实我们需要Object[]类型的数组的情况还是比较少的，所以建议使用有参的toArray方法。 有参的toArray方法使用时，传入的数组类型应该和集合元素的类型相同，且数组的大小为集合大小的数组。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/c_AbstractList.html":{"url":"java/util/c_AbstractList.html","title":"c_AbstractList","keywords":"","body":"AbstractList AbstractList类是List接口的超级实现类，里面实现了大部分的List接口中的方法。AbstractList类同时也是AbstractCollection抽象类的子类，对AbstractCollection中没有实现的iterator()方法进行了具体实现。所以AbstractList类同时具备List接口和AbstractCollection抽象类的特点。 如果要实现一个不可修改的集合，只需要复写get和size就可以了；要实现一个可以修改的集合，还需要复写set方法；如果要动态调整大小，就必须再实现add和remove方法。 Java中有序集合都直接或间接的继承该类，这就意味着到AbstractList这一层，，有序集合的基本方法都会被封装，这些方法具有普适性，可被Stack、ArrayList、LinkedList使用。 下面就让我们一起看一下AbstractList对集合的操作提供了哪些方法。 源码分析 两个内部类 在AbstractList类中定义了两个内部类Itr和ListItr，它们的定义如下： // Itr类提供了对Iterator类中方法的实现 private class Itr implements Iterator // ListItr提供了对ListIterator方法的实现 private class ListItr extends Itr implements ListIterator modCount变量 变量介绍： // 定义在AbstractList类中，该变量用于记录AbstractList子类在实现iterator、listIterator时使用，主要作用是记录修改次数。 // 即每次使用iterator、listIterator时，modCount的值都会赋予expectedModCount， // 每次操作前expectedModCount与modCount对比，不相等则表示可能有其它情况（如其它 // 线程、在for循环中删除某一个元素）对实例进行了修改，会抛出ConcurrentModificationException异常。 // 这就是fail-fast机制 protected transient int modCount = 0; // 定义在AbstractList的内部类Itr中 int expectedModCount = modCount; 比如在next()方法中就使用到了该变量： public E next() { // 通过modCount检查实例是否有变动 checkForComodification(); try { int i = cursor; E next = get(i); lastRet = i; cursor = i + 1; return next; } catch (IndexOutOfBoundsException e) { checkForComodification(); throw new NoSuchElementException(); } } final void checkForComodification() { // 二者不同则表示实例被修改，抛出异常 if (modCount != expectedModCount) throw new ConcurrentModificationException(); } 这个变量很重要，它保证了List相关集合遍历时数据的一致性，如下面的例子： List list = new ArrayList<>(3); list.add(\"mon\"); list.add(\"tues\"); list.add(\"thres\"); for(String str : list){ // position_1 if(\"mon\".equals(str)){ list.remove(str); // position_2 } } 在执行某次循环时，“position_1”处会抛出ConcurrentModificationException异常，反编译后我们可以知道，for-each循环其实还是调用的Iterator。我们上面分析了Iterator的next()方法，通过分析我们知道，每次调用next()法都会检查modCount和expectedModCount是否相等，不相等就会抛出ConcurrentModificationException，这里明显就是因为modCount和expectedModCount不相等抛出的异常。那为什么会不相等呢？ 难道是在执行“position_2”的remove()方法对modCount进行了修改？我们看一下remove()的源码： // remove()方法内部调用了fastRemove()方法 private void fastRemove(int index) { modCount++; // fr_position_1 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 的确，在“fr_position_1”处对modCount进行了+1，最终导致modCount和expectedModCount不相等。 add、indexOf、lastIndexOf、clear、removeRange方法分析 AbstractList类中提供了add方法的实现，直接将元素添加到集合的末尾，而addAll方法则是通过调用迭代器，从指定位置开始，逐个将元素添加到集合中，下面是add方法的源码： public boolean add(E e) { add(size(), e); return true; } 在该类中，indexOf、lastIndexOf、clear、removeRange方法都用到了Iterator或是ListIterator: public Iterator iterator() { return new Itr(); } public ListIterator listIterator(final int index) { rangeCheckForAdd(index); return new ListItr(index); } 是的，在AbstractList中，Iterator和ListIterator都是内部类并实现了Iterator接口，很自然的可以使用hasNext、next、remove方法对集合元素进行操作了。 subList方法及SubList类分析 值得注意的是，subList方法是操作的原集合，返回指定范围的原集合，即允许用户操作原集合的部分范围。 SubList类是AbstractList的子类，subList方法的功能就是在SubList类中实现的。 equals和hashcode方法 这两个方法分别对集合和集合中的元素进行了判断，所以如果想正确的使用这两个方法，则需要对这两个方法进行复写。 总结 AbstractList类主要是对集合接口的及其父类的方法进一步实现，该类中的方法对有序集合的操作更具有针对性。java通过这种层级间的方法实现，实现对各个类的高度利用。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/c_AbstractSequentialList.html":{"url":"java/util/c_AbstractSequentialList.html","title":"c_AbstractSequentialList","keywords":"","body":"c_AbstractSequentialList © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/C_Arrays.html":{"url":"java/util/C_Arrays.html","title":"C_Arrays","keywords":"","body":"C_Arrays 本来想等集合系列讲完再做Arrays工具类的讲解，然而，集合中用到该类的地方着实比较多，只能改变一下我的计划啦。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/M_copyOf.html":{"url":"java/util/M_copyOf.html","title":"M_copyOf方法解读","keywords":"","body":"概述 copyOf方法是Arrays类里经常被使用到的一个方法，该方法返回一个新的数组，这个新数组有什么特点呢？下面我们就来一起看一下这个方法吧。 特别说明：文中引入了其它文章，只是提供深入了解copyOf方法源码中涉及其它方法的途径，即便不去阅读这些引用，笔者相信也是可以读懂copyOf方法的。 方法详解 copyOf(T[], int) 方法源码： // original-要复制的数组，newLength-要返回的副本的长度 public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } 参数说明： original：要复制的数组， newLength：要返回的副本的长度 这里调用了另外一个重载的copyOf方法： public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 参数说明： original：要复制的数组， newLength：要返回的副本的长度 newType：要返回副本的类型 分析： (Object)newType == (Object)Object[].class：判断newType是不是Object类型数组。（因为用到了==号,java中同一类型的对象才能进行比较，比较的是内存地址，所以需要进行向上强转为Object才能比较，不然编译会抛异常：不可比较的类型。）。 如果newType是Object类型，则新创建一个长度为newLength的Object类型的数组。 如果newType不是Object类型，则调用Array.newInstance()方法。该方法创建了一个类型为newType的元素类型、长度为newLength的数组。 getComponentType(): 该方法返回newType数组中的元素类型。 然后执行了System类的静态方法arraycopy进行数组间的复制。（由Math.min(original.length, newLength)可看出，如果输入的长度newLength小于original数组的长度，那么该arraycopy方法会截取original数组，返回一个[0,newLength]的新数组）。 总结： 通过上面的分析，我们可以总结出copyOf(T[], int)方法的作用: 当给定长度大于原来数组时，返回一个包含原来数组元素的新数组。 当给定长度小于给定数组时，截断数组，方法会返回一个截断后的数组。 需要注意，这里调用System类的arraycopy静态方法，所以涉及到深复制和浅复制的问题。 一个小问题： 在(T[]) new Object[newLength]中，为什么Object[]可以强制转换成T[]呢？ 解答：判断(Object)newType == (Object)Object[].class 为true时，执行(T[]) new Object[newLength]，那T就是Object，newType也是Object[].class，所以可以强转成T[] 为false时，执行的是(T[]) Array.newInstance(newType.getComponentType(), newLength)，Array.newInstance返回的本质就是T[]，所以可以强转成T[]。 重载的copayOf方法 有了上面对copyOf(T[], int)方法的分析，其余重载的copayOf方法都很简单了，这里只 以byte[]类型的copayOf方法为例进行讲解，其余的方法都相似： 1.copayOf(byte[], int): public static byte[] copyOf(byte[] original, int newLength) { byte[] copy = new byte[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 在该方法中，因为已经确定了original的类型，所以就不用对其类型进行判断并向上转型了。 作用： 截断数组，当给定长度小于给定数组时，就可以实现截断的效果 其余的还有short、int、long、float、double、boolean、char类型对应数组的copayOf方法，作用都相同，就不再赘述了。 参考文档： Arrays.copyOf()方法详解-jdk1.8 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/C_ArrayList.html":{"url":"java/util/C_ArrayList.html","title":"C_ArrayList","keywords":"","body":"介绍 ArrayList类是List接口的实现类，就像它名字那样，“数组列表”即基于数组可调整大小的列表。允许存放null元素，与Vector相似，但去除了线程安全。其数据的顺序与插入的顺序一致。 JDK中这样定义该类： public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 可以看到，ArrayList是AbstractList的子类，同时实现了List接口。同时实现了三个标记接口： RandomAccess: 实现该接口的类，支持快速随机访问。 Cloneable: 实现该接口的类，支持克隆（重写clone方法）。 java.io.Serializable：实现该接口的类，支持序列化。 源码分析 变量 在ArrayList中有几个成员变量我们需要注意： // 默认初始化容量 private static final int DEFAULT_CAPACITY = 10; // 当实例大小为0时，ArrayList内部直接使用该数组 private static final Object[] EMPTY_ELEMENTDATA = {}; // 当向空实例中添加元素后，ArrayList内部直接使用该数组 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; // 数组缓冲区。当空实例添加完第一个元素，则实例的容量将扩展为DEFAULT_CAPACITY // transient标明了该变量不用序列化，因为序列化时会直接读取该数组的元素进行序列化，所以就不用序列化该变量了，可参考ArrayList中的writeObject()方法 transient Object[] elementData; // 为数组分配的最大容量 private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 从这几个变量的定义中可以看出，ArrayList的实质就是数组。这就不难解释，为什么ArrayList能被标记为支持快速随机访问的类了（因为数组的访问，本身就是一种快速随机访问）。 构造方法 ArrayList提供了3个构造方法： // 初始化一个为指定size的list public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } // 初始化一个指定容量的list public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } // 根据给定的Collection创建一个List（其实ArrayList就是一个Collection,不是吗？） public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 重要方法 ArrayList中与AbstractList区别的一些新实现 以下方法，在AbstractList中都是基于Iterator实现的，而在ArrayList中却不是: indexOf(Object o)：不再通过Iterator来实现 lastIndexOf(Object o)：不再通过Iterator来实现 toArray()：不再通过Iterator来实现，可能会截断原集合 toArray(T[] a)：带类型的转换。转数组时，尽量使用该方法。 我们应该这样使用: List list = new ArrayList<>(2); list.add(\"guan\"); list.add(\"bao\"); String[] array = new String[list.size()]; array = list.toArray(array); set()方法 将指定元素替换到指定位置，并返回原位置上的元素。 public E set(int index, E element) { rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; } 添加 添加涉及到ArrayList的内存扩容问题，所以更加值得关注。 // 1.在列表末尾添加元素 public boolean add(E e) { // 确保数组容量足够 ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } // 2.确保数组容量足够的方法 private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } // 3.计算容量 private static int calculateCapacity(Object[] elementData, int minCapacity) { // 如果是第一个添加的元素，则容量为DEFAULT_CAPACITY if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } // 5.又执行了ensureExplicitCapacity方法进行容量判断 private void ensureExplicitCapacity(int minCapacity) { modCount++; // 超出容量则扩容 if (minCapacity - elementData.length > 0) grow(minCapacity); } // 5.扩容 private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 扩容为原来的1.5倍 // 新容量 = 旧容量*1/2 + 旧容量 int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容后的还不够，则直接用给定的容量minCapacity if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } // 6.最大容量限度处理及内存溢出判定 private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } OK，到这里内存扩容机制就清楚了。首次创建一个空数组，第一次向集合中插入数据的时候，空数组容量扩容为10。如果容量不够，则扩充为原来的1.5倍，如果还不够，就需要给定的长度作为集合的新容量了。 一个问题： 上面的扩容机制，一定程度上缓解了扩容时频繁copy的问题，但当处理大量数据时，还是会出现频繁copy的问题，ArrayList为我们提供了两种可行的方案： 使用带有初始化容量的构造器ArrayList(int initialCapacity)。 预测到添加的数据量可能比较大，那么先进行扩容，再添加数据。扩容方法ensureCapacity(int minCapacity)，该方法调用的还是ensureExplicitCapacity(int minCapacity) 其它部分方法 还有一些方法，这里只列举出方法作用，不做详细说明了： trimToSize()：将elementData的大小设置为size大小，释放无用内存 remove(int index)：删除指定位置的元素，并返回该元素。 remove(Object o)：删除在集合中第一次出现的该元素。 removeRange(int fromIndex, int toIndex)：删除指定索引范围的元素 writeObject(java.io.ObjectOutputStream s): 序列化 总结 经过上面的分析，我们知道ArrayList就是基于数组实现的，所以方便随机访问，但不适合大量数据的插入。如果要进行数据的插入，可以考虑一下三种方式： 使用带有初始化容量的构造器ArrayList(int initialCapacity)。 使用ensureCapacity(int minCapacity)，先扩容再插入。 使用LinkedList。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/ArrayList_remove.html":{"url":"java/util/ArrayList_remove.html","title":"ArrayList遍历删除元素","keywords":"","body":"ArrayList遍历删除元素 回想起来，开发过程中遇到过很多坑，一步步的走来，确实真的挺不容易。ArrayList遍历删除就有一个坑，如果不从源码上分析，很难了解这个坑产生的原因。我阅读源码的习惯就是从这个坑开始的，所以要好好记录一下。 问题复现 在List中定义元素：Monday、Tuesday、Thresday，遍历去掉List中元素为\"Monday\"的元素，打印输出其它元素。 for循环删除元素 问题分析 easy，代码实现如下： List list = new ArrayList<>(3); list.add(\"Monday\"); list.add(\"Tuesday\"); list.add(\"Thresday\"); for(int i = 0; i 具体实现是使用for循环遍历了一个List,当List中的元素为\"Monday\"时，调用ArrayList的remove方法删除\"Monday\"这个元素。 控制台输出：thresday 纳尼？我要的“Thresday”呢？来掰着手指头分析一下： 第一次循环，循环变量i（即下标）的值为0，List中是这样的： 0 1 2 Monday Tuesday Thresday 执行完“position_1”处的代码后变成： 0 1 Tuesday Thresday 由于continue的存在，第一次循环执行完不会打印任何东西。 第二次循环，而此时循环变量i值为1，所以直接打印了“Thresday”，完美的忽略了“Tuesday”。 解决方法 既然知道了问题，那本着方法总比问题多的原则，试着改进一下。通过上面的分析可以知道是由于删除完元素，循环变量i的值变大了，那么很好办： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); for(int i = 0; i 一个小问题：上面的代码能优化一下吗？当然可以，请接着往下看。 倒序for循环删除元素 倒叙遍历方式实现： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); for(int i = list.size() - 1; i >= 0; i--){ if(\"thresday\".equals(list.get(i))){ list.remove(list.get(i)); // position_2 continue; } System.out.println(list.get(i)); } 这种方式的实现解决了每次删除完要修正下标（即循环变量i）的问题,可以来分析一下为什么： 第一次循环，i的值为2，List中是这样的： 0 1 2 Monday Tuesday Thresday 执行完“position_2”处的删除操作后，continue;所以第一次循环什么都不输出。 第二次循环，i的值为1，List中是这样的： 0 1 Monday Tuesday 所以刚好取得我想要的值“Tuesday”。这是巧合吗？不是的。删除一次元素，每次下面都减1，所以这是逻辑上的正确表达。 for-each循环删除元素 程序的世界就是那么让人兴奋。后来,我又认识了“A new girl”——for-each，她可以提供更加方便的遍历操作。直接上......代码： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); for(String str : list){ if(\"monday\".equals(str)){ list.remove(str); continue; } System.out.println(str); } - -！比上次还严重，程序直接抛异常：java.util.ConcurrentModificationException。I did not do anything...... 问题分析 为什么会抛出ConcurrentModificationException异常呢？拿出我的尚方宝剑：javap，以下是反编译结果： 37: invokeinterface #8, 1 // 调用方法： java/util/List.iterator()方法 42: astore_2 43: aload_2 44: invokeinterface #9, 1 // 调用方法： java/util/Iterator.hasNext()方法 49: ifeq 92 52: aload_2 53: invokeinterface #10, 1 // InterfaceMethod java/util/Iterator.next()方法 从上面可以看出，for-each循环是通过调用Iterator迭代器实现的，而Iterator的核心方法是hasNext和next方法。而在ArrayList类中的内部类Itr，就是对Iterator接口的实现类。 以下列出Itr的部分源码： private class Itr implements Iterator { int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() {} public boolean hasNext() { return cursor != size; } @SuppressWarnings(\"unchecked\") public E next() { checkForComodification(); // position_3 int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; } final void checkForComodification() { if (modCount != expectedModCount) throw new ConcurrentModificationException(); } } 我们发现在next方法的position_3处调用的checkForComodification方法中，当modCount和expectedModCount不相等时，会抛出ConcurrentModificationException异常。在AbstractList中我们分析过,modCount时记录集合被修改的次数。由此可知，抛出异常时modCount和expectedModCount不相等。通过跟踪源码我发现，在执行如下代码时: list.remove(str); modCount值被加1： public boolean remove(Object o) { if (o == null) { for (int index = 0; index 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } 所以在循环再次执行到next()方法时，modCount和expectedModCount不相等。 解决方法 既然不能使用ArrayList中的remove方法，我们该如何实现删除呢？ 在内部类Itr中，有一个remove方法,所以我们直接将代码改成： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); Iterator iterator = list.iterator(); while (iterator.hasNext()){ String str = iterator.next(); if(\"monday\".equals(str)){ iterator.remove(); continue; } System.out.println(str); } 控制台输出： tuesday thresday 让我们看一下Itr中remove方法的源码： public void remove() { if (lastRet 从源码可看出，在删除完元素后，会将modCount重新赋值给expectedModCount。 removeIf()方法循环遍历删除元素 List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); System.out.println(list); list.removeIf(str -> \"tuesday\".equals(str)); System.out.println(list); 拓展延伸 在使用for-each循环时还会遇到一个问题，就是在使用ArrayList的remove方法删除元素后，没有抛出ConcurrentModificationException异常： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); for(String str : list){ if(\"tuesday\".equals(str)){ // 注意这里删除的时tuesday list.remove(str); continue; } System.out.println(str); } 但是控制台只输出了：monday 上面的分析我们已经知道，for-each循环其实时通过Iterator实现的，所以我们直接把上面代码转成Iterator实现的方式： List list = new ArrayList<>(3); list.add(\"monday\"); list.add(\"tuesday\"); list.add(\"thresday\"); Iterator iterator = list.iterator(); while (iterator.hasNext()){ String str = iterator.next(); if(\"tuesday\".equals(str)){ list.remove(); continue; } System.out.println(str); } 控制台还是只输出了：monday 其实这个还是涉及到Itr内部类的源码，其中hasNext()方法源码如下： int cursor; // 光标，返回下一个元素的索引 public boolean hasNext() { return cursor != size; } 可以知道，while循环执行循环体的条件时光标不等于集合大小，即集合循环的下一个元素存在。我们调用完下面的代码后: list.remove(str); 集合中的元素会减少一个，所以集合的size就减一。 再回顾以下next()方法源码： public E next() { checkForComodification(); // position_3 int i = cursor; if (i >= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i >= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; // 光标加1 return (E) elementData[lastRet = i]; } 每次调用完next方法，光标都会加1。到这里我们就可以很确定ArrayList中Itr循环过程了：每次调用hasNext通过光标的值和集合的size来判断集合中是否还有元素需要循环，每次调用next方法，都会对光标增加1，知道光标的值与集合的size相等，则表示集合中的元素已经被遍历完成。 回到问题： 第二次循环，cursor光标的值为1，集合size为2。 第二次循环删除元素，光标值没有变化还是1，集合size减小1变为1。 第三次循环调用hasNext发现cursor == size，循环结束，自然就不会再打印thresday了。 总结 循环遍历删除元素，有四种有效的方法： 使用removeIf()方法 使用Iterator的remove()方法 使用for循环正序遍历 使用for循环倒序遍历 看似一个简单的循环遍历删除，如果不了解源码，很有可能掉坑里。加油~！奥里给！！！ © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_Collection.html":{"url":"java/util/I_Collection.html","title":"I_Collection","keywords":"","body":"I_Collection Collection接口是Iterable接口的子接口，所以只要实现Collection接口的类，都拥有for-each循环的能力。同时，Collection接口还是List、Set和Queue接口的父接口，所以该接口中的方法既可以操作Set集合，也可以用于操作List和Queue集合。 方法 既然是接口，那么就是对行为的抽象。我将该接口中操作集合元素的行为分为以下类型： 获得集合属性相关的方法： size(): 返回集合中元素的数量。 isEmpty(): 判断集合是否有元素，如果没有返回true。 操作集合相关方法： iterator(): 返回操作该集合的迭代器。 toArray(): 返回一个包含集合所有元素的新创建的数组。 equals(Object): 比较指定对象与此集合的相等性。 hashCode(): 返回该集合的hash code值。 spliterator()：返回一个Spliterator迭代器。 stream()：返回一个以此集合为源的Stream对象。 parallelStream()： 返回一个以此集合为源的可能并行的Stream对象。 添加： add(E): 向集合中添加一个元素，操作成功则返回true。 addAll(Collection): 向集合中添加另外一个集合的所有元素。成功则返回true。 删除： remove(Object): 删除集合中的某个元素，操作成功则返回true。 removeAll(Collection): 删除本集合中指定集合所拥有的所有元素，成功则返回true。 removeIf(Predicate): 根据条件，删除集合中的元素，jdk1.8新增方法，相关介绍请移驾M_removeIf。 修改： retainAll(Collection): 将当前集合中在指定集合没有的元素删除掉，保留在指定集合中有的元素。 clear(): 清空当前集合中的元素。 查询： contains(Object): 判集合中是否包含指定的元素，包含则返回true。 containsAll(Collection): 判断集合是否包含另外一个集合的所有元素，是则返回true 以上就是Collection接口的所有方法。 作为一个接口，就是对行为的抽象，所以Collection接口中的方法都是操作集合的一些行为。而操作集合的行为，一般都少不了增删改查、获得集合属性等。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_Collection/M_removeIf.html":{"url":"java/util/I_Collection/M_removeIf.html","title":"M_removeIf方法解读","keywords":"","body":"M_removeIf方法解读 该方法使1.8新增方法，使用该方法，可以根据条件删除集合中的元素。 例子 1.7 & 1.8 删除集合中符合条件的元素。 jdk 1.7 删除集合中为\"b\"的元素 import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); System.out.print(list); System.out.println(); Iterator itr = list.iterator(); while(itr.hasNext()){ if(\"b\".equals(itr.next())){ itr.remove(); } } System.out.print(list); } } 上面的代码利用Iterator迭代器来删除list中为“b”的元素。来看看执行结果： > javac Test.java > java Test [a, b, c] [a, c] 从结果可以看出，list中为“b”的元素成功被删除了。 jdk 1.8 删除集合中为\"b\"的元素 import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); System.out.print(list); System.out.println(); list.removeIf(str -> \"b\".equals(str)); System.out.print(list); } } 上面的代码通过jdk 1.8来删除list中为“b”的元素。我们来看一下结果： > javac Test.java > java Test [a, b, c] [a, c] 显然，删除成功了。这也是为什么我们需要升级技术的一个原因吧。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/C_collections/C_collections.html":{"url":"java/util/C_collections/C_collections.html","title":"C_collections","keywords":"","body":"collections 这个类包含对集合进行操作的静态方法。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/C_collections/M_shuffle.html":{"url":"java/util/C_collections/M_shuffle.html","title":"M_shuffle方法解读","keywords":"","body":"伊始 有这么一个场景：有一个抽奖活动，需要对几种奖品随机发放。我们可以将不同的奖品类别放入List，然后调用shuffle方法打乱这个List中元素的顺序，然后get(0),即可获得随机的一个奖品。 ArrayList integerList = new ArrayList<>(); integerList.add(0); integerList.add(1); integerList.add(2); Collections.shuffle(integerList); // 控制台可能打印0、1、2中的任何一个 System.out.println(integerList.get(0)); 方法作用： shuffle(List list)：使用默认的随机源，随机排列指定的列表。所有排列将以近似相等的可能性发生。 shuffle(List list, Random rnd)：使用指定的随机源，随机排列指定的列表。假设随机性的来源是公平的，那么所有排列都会以相同的可能性发生。 方法原理 以下是jdk源码（1.8）： public static void shuffle(List list, Random rnd) { int size = list.size(); if (size 1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i>1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i 上面代码先判断list的size是否小于SHUFFLE_THRESHOLD(5)或者实现RandomAccess接口，如果符合条件，则执行swap(List list, int i, int j)方法进行交换；如果不符合条件，则把list转为数组，数组执行swap(Object[] arr, int i, int j)（注意这里是另外一个swap()方法哦）方法进行交换，交换之后的数组循环转回List。 两个swap()方法： swap(Object[] arr, int i, int j) private static void swap(Object[] arr, int i, int j) { Object tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } 有三个参数： list：要交换元素的list。 i、j: 是两个要交换元素的下标 i: shuffle()方法中是从list的最后一个下标开始 j：列表中随机的一个下标 然后让i、j下标的元素进行交换。 swap(List list, int i, int j)方法： public static void swap(List list, int i, int j) { // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method final List l = list; l.set(i, l.set(j, l.get(i))); } i、j参数的含义和上面的swap(Object[] arr, int i, int j)方法含义相同，这两个swap方法都是使用了洗牌算法，在原数组中交换选择元素的位置。 但是swap(List list, int i, int j)方法中有一个需要注意的地方：final List l = list，这里为什么不直接用list，而是通过使用副本 l 进行操作呢？使用中间变量（副本）是为了规避泛型的缺点!不理解可以参考文末的参考文档。 两个疑问 到这里我产生了两个个疑问： shuffle方法中，判断条件为什么是size是否小于SHUFFLE_THRESHOLD(5)和实现RandomAccess接口？ 为什么符合条件就直接交换？不符合条件就转为数组再交换 对于SHUFFLE_THRESHOLD为什么是5，我大致查了一下，没有发现，如果有哪位仁兄知道，期待告知点这里，暂且全当是一个Lucky Number吧。 RandomAccess是一个空接口： public interface RandomAccess { } 也可以叫做标记接口。List类中支持快速访问的接口去实现它，也就是说，实现了该接口的类的数据结构应该是支持快速访问的。比如ArrayList类，随机访问一个元素(get(i))所花费的时间复杂度是O(1)。而LinkedList底层是链表实现，随机访问一个LinkedList中元素的时间复杂度是O(n)(最坏情况下)，所以LinkedList没有实现这个接口。 所以如果是LinkedList,可以转为Array再进行洗牌操作，是比较明智的。 标记接口：java开发者还是比较爱用的，通常会通过某个类是否实现了标记接口进行判断，如果实现了会进行一些特殊处理。jdk中中就比较常见，比如此时的shuffle方法中的RandomAccess接口，Spring在初始化bean实例时也会在initializeBean方法中判断要实例化的bean是否实现InitializingBean接口。 参考资料： 爲什麼Collections.swap複製輸入列表？ 为什么Collections.swap将目标列表分配给原始类型的变量？ Java 泛型，你了解类型擦除吗？ 三种洗牌 源码分析 Collections.shuffle()源码分析 ArrayList复杂度 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/i_deque.html":{"url":"java/util/i_deque.html","title":"I_Deque","keywords":"","body":"Deque介绍 Deque是double ended queue，即双端队列的意思。允许元素从队列的两端向队列中添加、删除元素。 方法介绍 Deque接口中的方法一共有一下四部分： Deque定义的方法 (add\\offer\\remove\\poll\\get\\peek)First或Last从双端操作元素。 removeFirstOccurrence(Object o)：从双端队列头部移除第一次出现的指定元素。 removeLastOccurrence(Object o)：从双端队列尾部移除第一次出现的指定元素。 descendingIterator()：返回一个反转的双端队列Iterator迭代器。 继承自Queue的方法 add、offer、remove、poll、element、peek这些方法与Queue中定义的一样，这里不再赘述。 Stack栈方法 void push(E e)： 入栈，此方法等效于addFirst()。 E pop()：出栈，此方法等效于 removeFirst()。 继承自Collection的方法 remove、contains、size、iterator方法。 小结 向文章开头介绍的那样，Deque定义了对双端队列从两端操作队列中元素的方法，这些方法中的每一种都以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值null或false，具体取决于操作。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_iterator.html":{"url":"java/util/I_iterator.html","title":"I_Iterator","keywords":"","body":"I_Iterator Iterator顾名思义就是迭代器，这是自jdk1.2起就存在的专门用于集合的迭代器参数化接口。 用法举例 import java.util.ArrayList; import java.util.Iterator; public class Test { public static void main(String[] paramArrayOfString) { ArrayList arrayList = new ArrayList(); arrayList.add(\"a\"); arrayList.add(\"b\"); arrayList.add(\"c\"); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { String str = iterator.next(); System.out.println(str); } } } 运行结果： > java Test a b c 上面定义了一个ArrayList，然后通过iterator对ArrayList进行了遍历。 接口方法 hasNext()：判断集合是否有下一个元素 next()：返回集合的下一个元素 remove()：移除集合中的某一个元素 forEachRemaining(Consumer action)：jdk1.8新增方法，对集合中剩余遍历的元素执行给定的操作（action） 迭代器Iterator对集合中的元素挨个操作，来实现循环遍历。所以Iterator更像是指针的一种抽象，通过不断的移动指针的指向，来遍历内存中的数据。但是指针和迭代器确实不是同一概念，这里只是为了更加形象的描述迭代器（二者有本质的不同：比如迭代器返回的是对象的引用而不是对象的值、指针能够指向函数而迭代器不能。） 在jdk1.8之前：接口中的成员一律默认是 public 类型。接口中的变量默认被指定为public static final类型；接口中的方法默认时public abstract类型的抽象方法，而我们都知道抽象方法不能拥有方法体。 我们注意到remove和forEachRemaining方法都有方法体，这是为什么呢？jdk1.8对接口进行了增强，该版本针对接口新增了2大特性：1.static方法，2.default修饰符。我们注意到remove和forEachRemaining方法都是通过default修饰的，所以才使得它们能够拥有方法体。所以，jdk1.8中，如果要在接口中定义有方法体的方法，可以通过使用static或者是default关键字对方法进行修饰。 参考资料： 迭代器和指针的区别 Java8接口增强 深入理解Java的接口和抽象类 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_List.html":{"url":"java/util/I_List.html","title":"I_List","keywords":"","body":"I_List List接口是Collection接口的子接口，代表集合家族中有序、可重复的集合。集合中的每一个元素，都有其对应的索引。 方法 List接口既然是接口，那么就是对行为的抽象。同时它还是Collection接口的子接口,那么它当然拥有Collection接口里的全部方法。所以在Collection接口里有的方法，这里有不再赘述了。 操作： replaceAll(UnaryOperator): 根据UnaryOperator指定的计算规则重新设置List集合的所有元素。比如根据集合中元素的长度重新来作为新的集合。 sort(Comparator): 根据Comparator参数对List集合进行排序。源码中其实时调用了Arrays.sort()方法进行的排序，然后通过ListIterator迭代器进行设置集合元素。Arrays和ListIterator后续章节会进行讲解。比如根据集合中元素的长度重新排序。 添加： add(int, E):在指定位置插入指定的元素，该位置后面的元素索引全部加1。 addAll(int, Collection): 在指定位置插入指定的集合元素，增加后院元素的索引。 删除： remove(Object): 该方法在Collection中定义，List集合删除集合中的某个元素，判断集合中的元素是不是目标元素，是根据equals()方法进行判断的。 remove(int): 删除指定位置的元素。 修改： set(int, E): 将指定位置修改为指定的元素。 查询： get(int): 获得指定位置的元素。 indexOf(Object): 返回指定元素在List中第一次出现的位置索引。 lastIndexOf(Object): 返回指定元素在List中最后一次出现的位置索引。 subList(int,int): 获得从指定的开始位置到结束位置所有集合元素组成的子集合。 属性： listIterator()：获得列表元素的列表迭代器。 listIterator(int): 从列表中指定的位置开始，返回列表中元素的列表迭代器。 从上面可以看出，相比于Collection接口，List集合里增加了一些根据索引来操作集合元素的方法。 有个很有意思的问题：既然List接口是Collection接口的子接口，那么它当然拥有Collection接口里的全部方法，可是为何在List接口中又重新定义了size、isEmpty等方法呢？我们可以想像一下，当jvm发现几个类之间时继承关系，如果要使用顶级父类的方法，是不是还要一个类一个类的去调用呢？喝口咖啡，当然不会允许这样！为了避免一层层向父级调用，所以在子类中也会同样得定义父类拥有的方法。为了提高性能，java的全力以赴可见一斑。 参考资料： 《疯狂Java讲义》 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_ListIterator.html":{"url":"java/util/I_ListIterator.html","title":"I_ListIterator","keywords":"","body":"介绍 ListIterator接口是Iterator接口的子接口，所以拥有Iterator接口的所有方法。而它的作用也像它的名字一样简单直接，就是只能用于List及其子类的迭代器。 方法 这里只介绍其相对其父类Iterator独有的方法展开介绍。 查询： hasPrevious(): 是否拥有上一个元素。 previous(): 获得列表中的上一个元素。 nextIndex(): 获得下一个元素的坐标。 previousIndex(): 获得上一个元素的坐标。 修改： set(E): 将next()或者previous()返回的元素替换成指定的元素。 添加： add(E): 将指定的元素添加到列表中。添加的位置是next()返回的元素（如果有的话）之前，或者是previous()返回的元素（如果有的话）之后。 从上面方法中可以看出，ListIterator接口增加了从后向前遍历列表的功能，在I_List接口中我们讲到,List集合中，每一个元素都有其对应的坐标，所以这里也增加了获取坐标的方法。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/util/I_Queue.html":{"url":"java/util/I_Queue.html","title":"I_Queue","keywords":"","body":"队列介绍 队列是简单的数据结构之一，它遵从FIFO（即先进先出的）的原则，可以想象我们平时排队，第一个排队的总在最前面。而与之类似的一种数据结构是栈，但是栈遵从FILO（即先进后出）原则，比如我们放盘子，第一个放的总在最下面。 队列在软件开发中担任着重要的职责，java函数的调用用到了栈的技术，在处理并发问题时，BlockingQueue很好的解决了数据传输的问题。 JDK队列相关的顶级接口是Queue,它直接继承自Collection,证明它也是集合的一份子。下面就让我们看看Queue接口中定义了哪些方法。 方法介绍 add(E)：向队列中添加元素。 offer(E)： 向队列中添加元素，与add方法相比，当容量收到限制时，应该使用改方法。 remove(): 从队列头部删除并返回头部元素，如果队列为空，则抛出异常。 poll(): 从队列头部删除并返回头部元素，如果队列为空，则返回null。 element(): 获取队列头部元素但是不从队列移除改元素，如果队列为空，则抛出异常。 peek(): 获取队列头部元素但是不从队列移除改元素，如果队列为空，则返回。 小结 Queue接口定义了队列添加、移除、获取元素的方法。 这些方法中的每一种都以两种形式存在：一种在操作失败时引发异常，另一种返回特殊值。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/lang.html":{"url":"java/lang/lang.html","title":"lang","keywords":"","body":"lang © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/I_Iterable.html":{"url":"java/lang/I_Iterable.html","title":"I_Iterable","keywords":"","body":"I_Iterable 该接口是集合的顶级接口，正如jdk中注释的那样，实现了该接口，则可以进行for-each循环。 方法 iterator：该方法返回一个泛型类型的迭代器。 forEach：jdk1.8新增方法，对集合中每个元素遍历执行给定的操作。 spliterator：jdk1.8新增方法，该方法提供了一个可以并行遍历元素的迭代器，以适应现在cpu多核时代并行遍历的需求。更多相关介绍请查看文末参考资料。 方法探究 iterator方法 Iterable接口既然能让它的实现类能够进行for-each循环，那我们就拿ArrayList类来做个小示例（ArrayList是Iterable接口的子孙接口）： import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); for (String str : list) { System.out.println(str); } } } 编译运行后控制台输出： > javac Test.java > java Test a b c 那for-each到底是怎么进行循环的呢？我们通过javap命令对字节码进行反编译，看看能不能得出答案。 反编译后的字节码输出如下： public static void main(java.lang.String[]); Code: 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.\"\":()V 7: astore_1 8: aload_1 9: ldc #4 // String a 11: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 14: pop 15: aload_1 16: ldc #6 // String b 18: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 21: pop 22: aload_1 23: ldc #7 // String c 25: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 28: pop 29: aload_1 30: invokevirtual #8 // 注释1 Method java/util/ArrayList.iterator:()Ljava/util/Iterator; 33: astore_2 34: aload_2 35: invokeinterface #9, 1 // 注释2 InterfaceMethod java/util/Iterator.hasNext:()Z 40: ifeq 63 43: aload_2 44: invokeinterface #10, 1 // 注释3 InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object; 49: checkcast #11 // class java/lang/String 52: astore_3 53: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 56: aload_3 57: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 60: goto 34 63: return 果然，从字节码文件我标注的注释1、2、3可以看出，其实for-each最终还是被jvm通过调用Iterator迭代器实现的。 forEach方法 相信细心的小伙伴已经发现，forEach方法和I_Iterator中的forEachRemaining方法，二者都是对元素遍历执行给定的操作,那为何会有这2个方法呢？这不是多余吗？ 其实二者有所不同： forEach方法使用的是for-each循环遍历，而forEachRemaining方法使用迭代器Iterator遍历元素。 forEach方法是对Iterable中的所有元素进行遍历，可以多次调用；forEachRemaining方法第二次调用不会做任何操作，因为不会有下一个元素。 spliterator方法 我们看一下该方法的源码： default Spliterator spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } 里面只有一行代码，调用了Spliterators的spliteratorUnknownSize方法，继续往下看： public static Spliterator spliteratorUnknownSize(Iterator iterator, int characteristics) { return new IteratorSpliterator<>(Objects.requireNonNull(iterator), characteristics); } 该方法通过有参构造器创建了一个IteratorSpliterator对象并返回，我们看这个构造器做了什么： public IteratorSpliterator(Iterator iterator, int characteristics) { this.collection = null; this.it = iterator; this.est = Long.MAX_VALUE; this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED); } 这个构造器其实就是使用给定的迭代器创建了Spliterator遍历器，并给定了初始大小。 而Spliterator是什么呢？Spliterator即splitable iterator可分割迭代器，它是一个接口，是Java为了并行遍历数据源中的元素而设计的迭代器，这个可以类比最早Java提供的顺序遍历迭代器Iterator，但一个是顺序遍历，一个是并行遍历。 Spliterator接口用到了Fork/Join设计思想，总得来说就是用递归的方式把并行的任务拆分成更小的子任务，然后把每个子任务的结果合并起来生成整体结果。这里对此不做深究，以后会专门对Fork-Join进行讨论。 参考资料： Java8里面的java.util.Spliterator接口有什么用？ © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/C_Class.html":{"url":"java/lang/C_Class.html","title":"C_Class","keywords":"","body":"C_Class Class类我理解为:java运行时类的类。 这个描述可能有点奇怪，可以暂时把它认为是描述java类的类。这也很好的体现了：万事万物皆对象。 方法 getComponentType():它是一个native方法. public native Class getComponentType(); 该方法的作用是返回一个数组的组件类型，如果该类不是数组，则返回null。那什么是数组的组件呢？就是数组元素！换句话说，就是返回数组中元素的类型。举例： String[] o = {\"aa\", \"bb\", \"cc\"}; System.out.println(o.getClass().getComponentType()); 控制台输出： class java.lang.String © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/reflect.html":{"url":"java/lang/reflect.html","title":"reflect","keywords":"","body":"reflect © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/reflect/C_Array.html":{"url":"java/lang/reflect/C_Array.html","title":"C_Array","keywords":"","body":"C_Array java数组类，里面定义了很多静态方法供程序员创建和使用数组。这些方法除了构造方法和获得实例的方法外，全都是native方法。 方法解读 newInstance(Class, int): 创建一个指定长度、类型的数组。 public static Object newInstance(Class componentType, int length) throws NegativeArraySizeException { return newArray(componentType, length); } private static native Object newArray(Class componentType, int length) throws NegativeArraySizeException; newInstance方法内部调用了原生native方法newArray，返回一个Object。该Object实质为数组类型(可以通过：返回值.getClass()方法查看所属类型)。 > newArray为本地原生方法，由虚拟机实现。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/C_System.html":{"url":"java/lang/C_System.html","title":"C_System","keywords":"","body":"C_System 方法 arraycopy(Object src, int srcPos, Object dest, int destPos, int length):复制数组。 具体讲解请点击M_arraycopy。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"java/lang/system/M_arraycopy.html":{"url":"java/lang/system/M_arraycopy.html","title":"M_arraycopy","keywords":"","body":"介绍 arraycopy作用主要是复制数组，从其名字不是驼峰写法就可看出其历史之久远。数组的复制涉及到深复制和浅复制的问题，我认为比较重要，所以这里摘出来单独进行讲解。 方法定义 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 参数： src：源数组 srcPos：源数组中读取数据的起始位置 dest: 目标数组 destPos: 写入目标数组的其实位置 length: 要复制的长度 该方法为native方法，具体由java虚拟机实现。 方法作用： 从数组src中复制元素数组desc。也就是说，把原数组src[srcPos,srcPos+length-1]位置的元素，复制到dest的[destPos,destPos+length-1]位置上。 这是一种覆盖性的复制，即目标数组dest复制之前destPos,destPos+length-1位置上的数据会被覆盖。 深复制与浅复制 当数组为一维数组，且元素为基本类型或String类型时，属于深复制，即原数组与新数组的元素不会相互影响。 数组为多维数组，或一维数组中的元素为引用类型时，属于浅复制，原数组与新数组的元素引用指向同一个对象 参考资料： System.arraycopy()方法详解 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"jvm/jvm.html":{"url":"jvm/jvm.html","title":"Jvm","keywords":"","body":"jvm © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"jvm/java_runtime_area.html":{"url":"jvm/java_runtime_area.html","title":"Java运行时数据区","keywords":"","body":"Java运行时数据区 Java虚拟机在执行java程序的过程中会把它管理的内存划分成若干个不同的数据区域。不同的区域有不同的作用，下面简单的介绍了各个区域的作用。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Spring源码解读 本节会对spring中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"spring/bean/bean.html":{"url":"spring/bean/bean.html","title":"初始化bean","keywords":"","body":"伊始 五一、双十一、双十二之类的活动，常常需要根据用户获得的奖品，做不同的处理，这样代码中很可能就会有不少的判断。 比如活动中的奖品有：现金、积分、优惠券、BD奖品等，如果用户获得现金，我们就要做现金的逻辑处理，如果获得积分就做积分逻辑的处理。我们可能会这么做： if(\"cash\".equals(prize)){ System.out.println(\"给用户发现金！\"); }else if(\"points\".equals(prize)){ System.out.println(\"给用户发积分！\"); }else if(\"coupons\".equals(prize)){ System.out.println(\"给用户发优惠券！\"); }else if(\"aiqiyi\".equals(prize)){ System.out.println(\"给用户发爱奇艺会员！\"); } 如果奖品很多，就进行很多个判断。不难发现，这样的代码可读性差、不易维护。我们可以使用策略模式优化它，优化demo会在后面的文章中更新。 这里可以通过org.springframework.beans.factory.InitializingBean接口来实现。而InitializingBean接口就是spring中bean的初始化方法之一。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"spring/bean/bean_initialization_method.html":{"url":"spring/bean/bean_initialization_method.html","title":"bean的初始换方法","keywords":"","body":"bean的初始换方法 Spring的Bean在初始化完成后及销毁之前，允许程序执行特定的操作。有一下三种方式定指定： 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 通过下面代码来验证： 配置文件spring-context.xml： 测试类： package com.init; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; /** * @author: yongmingcode * @create: 2020-04-22 17:43 */ public class TestInitializationBean implements InitializingBean, DisposableBean { public TestInitializationBean() { System.out.println(\"----------------------TestInitializationBean 构造方法执行------------------\"); } /** 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 */ public void afterPropertiesSet() throws Exception { System.out.println(\"TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行\"); } public void destroy() throws Exception { System.out.println(\"TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行\"); } /** 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 */ public void initMethod(){ System.out.println(\"TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行\"); } public void destroyMethod(){ System.out.println(\"TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行\"); } /** 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 */ @PostConstruct public void postConstruct(){ System.out.println(\"TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行\"); } @PreDestroy public void preDestroy(){ System.out.println(\"TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行\"); } public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\"); System.out.println(\"------------------------初始化完成------------------------------\"); context.close(); System.out.println(\"------------------------销毁完成------------------------------\"); } } 执行后控制台输出： 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.getSingleton()] DEBUG - Creating shared instance of singleton bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Creating instance of bean 'initAndDestroySeqBean' ----------------------TestInitializationBean 构造方法执行------------------ 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found init method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.postConstruct() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found destroy method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.preDestroy() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered init method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1ab9f17 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered destroy method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doCreateBean()] DEBUG - Eagerly caching bean 'initAndDestroySeqBean' to allow for resolving potential circular references 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeInitMethods()] DEBUG - Invoking init method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.postConstruct() TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeInitMethods()] DEBUG - Invoking afterPropertiesSet() on bean with name 'initAndDestroySeqBean' TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeCustomInitMethod()] DEBUG - Invoking init method 'initMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Finished creating instance of bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.initLifecycleProcessor()] DEBUG - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1ef3efa8] 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [PropertySourcesPropertyResolver.getProperty()] DEBUG - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source ------------------------初始化完成------------------------------ 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.doClose()] INFO - Closing org.springframework.context.support.ClassPathXmlApplicationContext@41f69e84: startup date [Wed Apr 22 18:06:25 CST 2020]; root of context hierarchy 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.destroySingletons()] DEBUG - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19b93fa8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,initAndDestroySeqBean]; root of factory hierarchy 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeDestroyMethods()] DEBUG - Invoking destroy method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.preDestroy() TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.destroy()] DEBUG - Invoking destroy() on bean with name 'initAndDestroySeqBean' TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.invokeCustomDestroyMethod()] DEBUG - Invoking destroy method 'destroyMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行 ------------------------销毁完成------------------------------ Disconnected from the target VM, address: '127.0.0.1:61729', transport: 'socket' 从执行结果可以看出： Bean在实例化的过程中：Constructor > @PostConstruct >InitializingBean > init-method Bean在销毁的过程中：@PreDestroy > DisposableBean > destroy-method 参考资料： Spring容器中的Bean几种初始化方法和销毁方法的先后顺序 spring的Bean初始化方法的2种方式 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"knacks/knacks.html":{"url":"knacks/knacks.html","title":"技巧","keywords":"","body":"记录一下日常开发代码中部分优化小结。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"knacks/if_else_decoupling.html":{"url":"knacks/if_else_decoupling.html","title":"if...else...解耦","keywords":"","body":"if...else...解耦 在spring的初始化bean中讲到，过深的if...else...条件判断使得代码变得可读性差、不易维护。 本文通过静态工厂+策略模式对if...else...实现解耦。 1.以初始化bean中发奖为例，首先定义一个接口： /** * @description: 发放奖励 * @author: yongmingcode */ public interface IHandOutPrize { void doHandOut(); } 2.定义发放现金奖励类： /** * @description: 发放现金奖励 * @author: yongmingcode */ @Service public class HandOutCash implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\" -------HandOutCash doHandOut-------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"cash\", this); } } 3.定义发放积分奖励类： /** * @description: 发放积分奖励 * @author: yongmingcode */ @Service public class HandOutPoint implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\"-------------HandOutPoint doHandOut -----------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"point\", this); } } 4.定义发放奖品的静态工厂类： /** * @description: 发放奖品的静态工厂 * @author: yongmingcode */ public class HandOutPrizeFactory { private static Map handOutPrizeMap = new HashMap(); public HandOutPrizeFactory() { } private static IHandOutPrize EMPTY = new EmptyHandOutPrize(); /** 注册 */ public static void registerHandOutPrize(String prizeType, IHandOutPrize handOutPrize){ handOutPrizeMap.put(prizeType, handOutPrize); } /** 获取 */ public static IHandOutPrize getHandOutPrize(String prizeType){ IHandOutPrize handOutPrize = handOutPrizeMap.get(prizeType); return handOutPrize == null ? EMPTY : handOutPrize; } private static class EmptyHandOutPrize implements IHandOutPrize{ public void doHandOut() { System.out.println(\" EmptyHandOutPrize \"); } } } 5.最后，写一个发放现金奖励类： /** * @description: if...else...解耦 * @author: yongmingcode */ public class IfElseDecoupling { public static void main(String[] args){ // 发放现金奖励 handOutPrize(\"cash\"); } private static void handOutPrize(String prizeType){ IHandOutPrize handOutPrize = HandOutPrizeFactory.getHandOutPrize(prizeType); handOutPrize.doHandOut(); } } 上面代码的解释： 定义了一个发放奖励的IHandOutPrize接口，该接口只有一个发放奖励的方法； HandOutCash、HandOutPoint是IHandOutPrize接口的两个实现类，同时实现了InitializingBean接口（该接口关介绍请移驾bean的初始化方法），并在afterPropertiesSet()方法中对当前类进行了注册； 通过静态工厂HandOutPrizeFactory类进行奖励的注册和获取； 在IfElseDecoupling类中进行发放奖励，如发放现金奖励只需要两行代码就够了。 总结： 优点：以上对if...else...形式代码进行了解耦重构，重构后的逻辑清晰、明了，如果新增一种奖品，只需要定义一个新的类即可，这样大大提高了代码的可读性和可维护性。 缺点：会增加很多类。 参考资料： 代码重构：用工厂+策略模式优化过多的if else代码块 我的Java设计模式-策略模式 Spring核心接口之InitializingBean © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"knacks/repeat_payment.html":{"url":"knacks/repeat_payment.html","title":"订单重复支付解决","keywords":"","body":"订单支付问题引入 线上购物已经成为当代年轻人生活的重要组成部分。 商品加入购物车 -> 提交订单 -> 进入订单详情 -> 确认支付。 这之间的问题很多，本篇文章主要对其中的一个问题进行放大讲解：用户点击支付以后，由于网络、事务失败等原因，用户账户（如支付宝）中的钱扣过了，可是系统中订单状态还是未支付，用户再次点击支付，这样，就造成了重复支付的问题。 问题分析 我们先来看一下支付流程： 上图是一个可能造成用户重复支付的支付流程，我们需要对这个流程进行改进，进而解决重复支付的问题。 问题解决 下图通过幂等性操作，对重复支付问题进行了解决： 上面的流程图极为模糊，内容可以勉强看清，希望读者可以自己动手画一下 下面来一起对上图进行分析： 用户下完单去支付，如果ack为0，则表明第一次进行支付操作； 将ack置为1，请求三方支付api； 支付成功，ack置为2，订单状态置为已支付。 情况一：如果支付失败，用户重新点击去支付： 重新支付，ack为1，则调用三方接口查询该笔订单是否支付成功； 支付成功，ack置为2，订单状态置为已支付。 * 注：三方查询可以通过订单对应的支付流水号进行查询。根据n值判断，如果3次支付都失败，则会触发系统的报警系统。 情况二：如果支付失败，用户重新点击去支付： 重新支付，ack为2，这是为什么呢？唯一的解释就是在扣款完成后，第三方（如支付宝）回调我们，我们在回调函数中对订单ack进行了修改。 支付成功，订单状态置为已支付。 情况三：如果支付失败，用户重新点击去支付： 重新支付，ack不是0、1、2中的任何一个，则表明系统出问题了，进行报警操作。 总结 上面通过幂等性操作，保证了用户支付的唯一性，解决了用户重复支付的问题。 用户下单流程中有许多坑，本文旨在提供了一个对用户重复支付问题的解决思路，如对上述解决思路有疑问或者不同见解，欢迎在下方留言探讨。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"knacks/nested_transactions.html":{"url":"knacks/nested_transactions.html","title":"spring嵌套事务失效解决","keywords":"","body":"数据陆续同步中......敬请期待！ © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-07 18:56:41 "},"knacks/to_many_fullgc.html":{"url":"knacks/to_many_fullgc.html","title":"FULLGC过多问题排查","keywords":"","body":"FULLGC过多问题排查 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2022-07-08 09:19:19 "}}