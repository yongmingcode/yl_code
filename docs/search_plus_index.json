{"./":{"url":"./","title":"介绍","keywords":"","body":"博客地址 技术博客——满月弓 【Gitbook】技术博客——满月弓 简 介 这是一个个人技术分享的网站。站中内容主要来源于博客、书籍以及笔者平时工作学习中知识点的总结。 以前自己的知识点都分门别类的记录在印象笔记和自己的个人主页，但最近服务器和域名都从百度云迁移了，而印象笔记更多的是自己使用，分享不便。我又发现，这是一个重新整理心中知识的机会，所以开启了这个技术分享的站点。 笔者一直认为，一件事物的兴盛，离不开无数贡献者的默默奉献。而知识，只有分享才会更有价值。笔者也愿意作为一名默默的贡献者，希望通过奉献自己的点点萤火，让知识传播与分享这把火燃的更旺！ 本站期望 志向立高远，学问做精细； 不积跬步，无以至千里。积累是人类永远谈不完的话题； 蚊子再小也是肉。记录的知识点不分主次，都需要认真咀嚼； 知其然，亦知其所以然。本站中的知识点，知道怎么用，更能知道为什么能这么用。 勘误与支持 由于笔者技术有限，编写时间仓促，文章中难免出现一些错误或者不准确的地方，恳请读者批评指正。如果您有更多的宝贵意见，可以再我的github上新建issue，笔者会尽快解答，期待得到您的真挚反馈。github地址： https://github.com/yongmingcode/yl_code © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 17:22:50 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/java.html":{"url":"java/java.html","title":"Java","keywords":"","body":"JDK源码解读 本节会对项目开发中的知识点进行总结以及对jdk 1.8中的部分源码进行解读（文中如果未标明jdk版本，那默认就是jdk1.8版本），其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 14:34:47 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/series.html":{"url":"java/series.html","title":"系列","keywords":"","body":"系列 每个系列定义一组java知识点，方便读者对各个知识点的整体进行把控，站得高，看的远。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-30 15:01:58 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/series/collection.html":{"url":"java/series/collection.html","title":"集合","keywords":"","body":"伊始 阳春三月，草长莺飞,我很享受校园风光（比如说情人坡上的美女~），也常常会和小伙伴一起去旁听一些学校比较有意思的公开课。学校的阶梯教室、讲师的尊尊教导，常常会梦里萦绕（谨此怀念过去许久的美好校园时光）。 为了方便操作，我们常常会将同一类型的元素放在一个阶梯教室里，哦，就是放在一起。在java中，可能你马上会想到数组，确实，数组是一个很好的解决方案。 数组有个特点，它的底层实现是在内存中寻找一块连续的座位，然后把具有相同特点的元素放在一起。可是公开课，常常人满为患，我和小伙伴常常找不到一块连续的座位，如果我们非要一块连续的座位，那么很可能就会被告知OOM异常。或许某次我们非常幸运，找到了连着的座位，可是后来又来了几个小伙伴要一起旁听课,为了体现基友情，我们又要重新找连在一起的座位，重新创建数组，这样就很费精力......所以，我们常常分开坐。 为了解决类似上面的问题，java提供了令人非常激动的保存对象工具——集合。集合解决了“在任意时刻，任意位置，创建任意数量对象”的问题。 在本节，我们会去探索java中集合的实现，学习集合的使用，分析涉及的算法，看看用到的设计模式，体会设计者的设计思路。 以下是集合系列文章： I_Iterator I_Iterable I_Collection I_ListIterator I_List © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 14:34:47 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/util.html":{"url":"java/util/util.html","title":"util","keywords":"","body":"util java.util包存在rt.jar包中，该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 jdk提供的工具类目录，存在于rt.jar包中。 rt.jar代表runtime JAR,包含引导类bootstrap classes，包含所有核心JavaJava基础类运行环境的已编译calss文件，更多相关介绍可以参考文末参考资料。 参考资料 Java / JDK / JRE中的rt.jar是什么？ 为什么重要？ 了解java .lang 包,java.util包等常用包 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 14:34:47 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/c_AbstractCollection.html":{"url":"java/util/c_AbstractCollection.html","title":"c_AbstractCollection","keywords":"","body":"c_AbstractCollection AbstractCollection是唯一一个实现Collection接口的类，并且是一个抽象类。我们可以先看一下它的方法实现，再去分析这个类的作用。 方法 主要列出AbstractCollection重写父类的一些方法及其独有的方法。 构造方法 protected AbstractCollection() {} 属性相关方法： isEmpty()：判断集合是否为空，其标准是集合size()是否等于0。 contains(Object o)：判断集合中是否包含某个元素。 public boolean contains(Object o) { // 通过迭代器迭代进行比较集合中每个元素是否相等 Iterator it = iterator(); if (o==null) {// 分为null和不是null进行处理 while (it.hasNext()) if (it.next()==null) return true; } else { while (it.hasNext()) if (o.equals(it.next())) return true; } return false; } toArray(): 将集合转为数组。 public Object[] toArray() { // 准备了一个和集合size()大小的数组 Object[] r = new Object[size()]; Iterator it = iterator(); for (int i = 0; i © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/C_Arrays.html":{"url":"java/util/C_Arrays.html","title":"C_Arrays","keywords":"","body":"C_Arrays 本来想等集合系列讲完再做Arrays工具类的讲解，然而，集合中用到该类的地方着实比较多，只能改变一下我的计划啦。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 16:57:10 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/M_copyOf.html":{"url":"java/util/M_copyOf.html","title":"M_copyOf方法解读","keywords":"","body":"概述 copyOf方法是Arrays类里经常被使用到的一个方法，从名字中我们可以看出它主要功能就是实现数组之间的复制，Arrays类中重载了10个同名方法来应对不同数据类型的数组复制，那SE开发者是如何设计的呢？下面我们就来一起看一下这个方法吧。 方法详解 copyOf(T[], int) 方法源码： // original-要复制的数组，newLength-要返回的副本的长度 public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } 参数说明： original：要复制的数组， newLength：要返回的副本的长度 这里调用了另外一个重载的copyOf方法： public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 参数说明： original：要复制的数组， newLength：要返回的副本的长度 newType：要返回副本的类型 一行行来看： (Object)newType == (Object)Object[].class：判断newType是不是Object类型数组。因为用到了==号，比较的是内存地址，所以需要进行向上强转为Object才能比较，不然编译会抛异常：不可比较的类型(java中同一类型的对象才能进行比较)。 如果newType是Object类型，则新创建一个长度为newLength的Object类型的数组。 如果newType不是Object类型，则调用Array.newInstance()方法，创建一个类型为newType的元素类型、长度为newLength的数组。可参看C_Array中newInstance方法相关讲解。 newType.getComponentType(): 返回newType数组中的元素类型。可参看C_Class中getComponentType方法相关讲解。 2.然后执行了System类的静态方法arraycopy进行数组间的复制，可参看C_System中arraycopy方法相关讲解。（copyOf方法中传入的则是original数组的长度和newLength中较小的，所以如果输入的长度newLength小于original数组的长度，那么该arraycopy方法则只会返回一个只有original数组中下标从0到下标newLength的数组。） 一个小问题：(T[]) new Object[newLength]，为什么Object[]可以强制转换成T[]呢？ 判断(Object)newType == (Object)Object[].class 为true时，执行(T[]) new Object[newLength]，那T就是Object，newType也是Object[].class，所以可以强转成T[] 为false时，执行的是(T[]) Array.newInstance(newType.getComponentType(), newLength)，Array.newInstance返回的本质就是T[]，所以可以强转成T[]。 通过上面的分析，我们可以总结出copyOf(T[], int)方法的作用: 把源数组中元素的类型向上转型 截断数组，当给定长度小于给定数组时，就可以实现截断的效果 需要注意，这里调用了System的arraycopy方法进行的copy，所以涉及到深复制和浅复制的问题，请参考M_arraycopy 重载的copayOf方法 有了上面对copyOf(T[], int)方法的分析，其余重载的copayOf方法都很简单了，这里只 以byte[]类型的copayOf方法为例进行讲解，其余的方法都相似： 1.copayOf(byte[], int): public static byte[] copyOf(byte[] original, int newLength) { byte[] copy = new byte[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 在该方法中，因为已经确定了original的类型，所以就不用对其类型进行判断并向上转型了。 作用： 截断数组，当给定长度小于给定数组时，就可以实现截断的效果 其余的还有short、int、long、float、double、boolean、char类型对应数组的copayOf方法，作用都相同，就不再赘述了。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_Collection.html":{"url":"java/util/I_Collection.html","title":"I_Collection","keywords":"","body":"I_Collection Collection接口是Iterable接口的子接口，所以只要实现Collection接口的类，都拥有for-each循环的能力。同时，Collection接口还是List、Set和Queue接口的父接口，所以该接口中的方法既可以操作Set集合，也可以用于操作List和Queue集合。 方法 既然是接口，那么就是对行为的抽象。我将该接口中操作集合元素的行为分为以下类型： 获得集合属性相关的方法： size(): 返回集合中元素的数量。 isEmpty(): 判断集合是否有元素，如果没有返回true。 操作集合相关方法： iterator(): 返回操作该集合的迭代器。 toArray(): 返回一个包含集合所有元素的新创建的数组。 equals(Object): 比较指定对象与此集合的相等性。 hashCode(): 返回该集合的hash code值。 spliterator()：返回一个Spliterator迭代器。 stream()：返回一个以此集合为源的Stream对象。 parallelStream()： 返回一个以此集合为源的可能并行的Stream对象。 添加： add(E): 向集合中添加一个元素，操作成功则返回true。 addAll(Collection): 向集合中添加另外一个集合的所有元素。成功则返回true。 删除： remove(Object): 删除集合中的某个元素，操作成功则返回true。 removeAll(Collection): 删除本集合中指定集合所拥有的所有元素，成功则返回true。 removeIf(Predicate): 根据条件，删除集合中的元素，jdk1.8新增方法，相关介绍请移驾M_removeIf。 修改： retainAll(Collection): 将当前集合中在指定集合没有的元素删除掉，保留在指定集合中有的元素。 clear(): 清空当前集合中的元素。 查询： contains(Object): 判集合中是否包含指定的元素，包含则返回true。 containsAll(Collection): 判断集合是否包含另外一个集合的所有元素，是则返回true 以上就是Collection接口的所有方法。 作为一个接口，就是对行为的抽象，所以Collection接口中的方法都是操作集合的一些行为。而操作集合的行为，一般都少不了增删改查、获得集合属性等。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:35 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_Collection/M_removeIf.html":{"url":"java/util/I_Collection/M_removeIf.html","title":"M_removeIf方法解读","keywords":"","body":"M_removeIf方法解读 该方法使1.8新增方法，使用该方法，可以根据条件删除集合中的元素。 例子 1.7 & 1.8 删除集合中符合条件的元素。 jdk 1.7 删除集合中为\"b\"的元素 import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); System.out.print(list); System.out.println(); Iterator itr = list.iterator(); while(itr.hasNext()){ if(\"b\".equals(itr.next())){ itr.remove(); } } System.out.print(list); } } 上面的代码利用Iterator迭代器来删除list中为“b”的元素。来看看执行结果： > javac Test.java > java Test [a, b, c] [a, c] 从结果可以看出，list中为“b”的元素成功被删除了。 jdk 1.8 删除集合中为\"b\"的元素 import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); System.out.print(list); System.out.println(); list.removeIf(str -> \"b\".equals(str)); System.out.print(list); } } 上面的代码通过jdk 1.8来删除list中为“b”的元素。我们来看一下结果： > javac Test.java > java Test [a, b, c] [a, c] 显然，删除成功了。这也是为什么我们需要升级技术的一个原因吧。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:32 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/C_collections/C_collections.html":{"url":"java/util/C_collections/C_collections.html","title":"C_collections","keywords":"","body":"collections 这个类包含对集合进行操作的静态方法。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:30 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/C_collections/M_shuffle.html":{"url":"java/util/C_collections/M_shuffle.html","title":"M_shuffle方法解读","keywords":"","body":"伊始 有这么一个场景：有一个抽奖活动，需要对几种奖品随机发放。我们可以将不同的奖品类别放入List，然后调用shuffle方法打乱这个List中元素的顺序，然后get(0),即可获得随机的一个奖品。 ArrayList integerList = new ArrayList<>(); integerList.add(0); integerList.add(1); integerList.add(2); Collections.shuffle(integerList); // 控制台可能打印0、1、2中的任何一个 System.out.println(integerList.get(0)); 方法作用： shuffle(List list)：使用默认的随机源，随机排列指定的列表。所有排列将以近似相等的可能性发生。 shuffle(List list, Random rnd)：使用指定的随机源，随机排列指定的列表。假设随机性的来源是公平的，那么所有排列都会以相同的可能性发生。 方法原理 以下是jdk源码（1.8）： public static void shuffle(List list, Random rnd) { int size = list.size(); if (size 1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i>1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i 上面代码先判断list的size是否小于SHUFFLE_THRESHOLD(5)或者实现RandomAccess接口，如果符合条件，则执行swap(List list, int i, int j)方法进行交换；如果不符合条件，则把list转为数组，数组执行swap(Object[] arr, int i, int j)（注意这里是另外一个swap()方法哦）方法进行交换，交换之后的数组循环转回List。 两个swap()方法： swap(Object[] arr, int i, int j) private static void swap(Object[] arr, int i, int j) { Object tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } 有三个参数： list：要交换元素的list。 i、j: 是两个要交换元素的下标 i: shuffle()方法中是从list的最后一个下标开始 j：列表中随机的一个下标 然后让i、j下标的元素进行交换。 swap(List list, int i, int j)方法： public static void swap(List list, int i, int j) { // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method final List l = list; l.set(i, l.set(j, l.get(i))); } i、j参数的含义和上面的swap(Object[] arr, int i, int j)方法含义相同，这两个swap方法都是使用了洗牌算法，在原数组中交换选择元素的位置。 但是swap(List list, int i, int j)方法中有一个需要注意的地方：final List l = list，这里为什么不直接用list，而是通过使用副本 l 进行操作呢？使用中间变量（副本）是为了规避泛型的缺点!不理解可以参考文末的参考文档。 两个疑问 到这里我产生了两个个疑问： shuffle方法中，判断条件为什么是size是否小于SHUFFLE_THRESHOLD(5)和实现RandomAccess接口？ 为什么符合条件就直接交换？不符合条件就转为数组再交换 对于SHUFFLE_THRESHOLD为什么是5，我大致查了一下，没有发现，如果有哪位仁兄知道，期待告知点这里，暂且全当是一个Lucky Number吧。 RandomAccess是一个空接口： public interface RandomAccess { } 也可以叫做标记接口。List类中支持快速访问的接口去实现它，也就是说，实现了该接口的类的数据结构应该是支持快速访问的。比如ArrayList类，随机访问一个元素(get(i))所花费的时间复杂度是O(1)。而LinkedList底层是链表实现，随机访问一个LinkedList中元素的时间复杂度是O(n)(最坏情况下)，所以LinkedList没有实现这个接口。 所以如果是LinkedList,可以转为Array再进行洗牌操作，是比较明智的。 标记接口：java开发者还是比较爱用的，通常会通过某个类是否实现了标记接口进行判断，如果实现了会进行一些特殊处理。jdk中中就比较常见，比如此时的shuffle方法中的RandomAccess接口，Spring在初始化bean实例时也会在initializeBean方法中判断要实例化的bean是否实现InitializingBean接口。 参考资料： 爲什麼Collections.swap複製輸入列表？ 为什么Collections.swap将目标列表分配给原始类型的变量？ Java 泛型，你了解类型擦除吗？ 三种洗牌 源码分析 Collections.shuffle()源码分析 ArrayList复杂度 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:28 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_iterator.html":{"url":"java/util/I_iterator.html","title":"I_Iterator","keywords":"","body":"I_Iterator Iterator顾名思义就是迭代器，这是自jdk1.2起就存在的专门用于集合的迭代器参数化接口。 用法举例 import java.util.ArrayList; import java.util.Iterator; public class Test { public static void main(String[] paramArrayOfString) { ArrayList arrayList = new ArrayList(); arrayList.add(\"a\"); arrayList.add(\"b\"); arrayList.add(\"c\"); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { String str = iterator.next(); System.out.println(str); } } } 运行结果： > java Test a b c 上面定义了一个ArrayList，然后通过iterator对ArrayList进行了遍历。 接口方法 hasNext()：判断集合是否有下一个元素 next()：返回集合的下一个元素 remove()：移除集合中的某一个元素 forEachRemaining(Consumer action)：jdk1.8新增方法，对集合中剩余遍历的元素执行给定的操作（action） 迭代器Iterator对集合中的元素挨个操作，来实现循环遍历。所以Iterator更像是指针的一种抽象，通过不断的移动指针的指向，来遍历内存中的数据。但是指针和迭代器确实不是同一概念，这里只是为了更加形象的描述迭代器（二者有本质的不同：比如迭代器返回的是对象的引用而不是对象的值、指针能够指向函数而迭代器不能。） 在jdk1.8之前：接口中的成员一律默认是 public 类型。接口中的变量默认被指定为public static final类型；接口中的方法默认时public abstract类型的抽象方法，而我们都知道抽象方法不能拥有方法体。 我们注意到remove和forEachRemaining方法都有方法体，这是为什么呢？jdk1.8对接口进行了增强，该版本针对接口新增了2大特性：1.static方法，2.default修饰符。我们注意到remove和forEachRemaining方法都是通过default修饰的，所以才使得它们能够拥有方法体。所以，jdk1.8中，如果要在接口中定义有方法体的方法，可以通过使用static或者是default关键字对方法进行修饰。 参考资料： 迭代器和指针的区别 Java8接口增强 深入理解Java的接口和抽象类 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:13 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_List.html":{"url":"java/util/I_List.html","title":"I_List","keywords":"","body":"I_List List接口是Collection接口的子接口，代表集合家族中有序、可重复的集合。集合中的每一个元素，都有其对应的索引。 方法 List接口既然是接口，那么就是对行为的抽象。同时它还是Collection接口的子接口,那么它当然拥有Collection接口里的全部方法。所以在Collection接口里有的方法，这里有不再赘述了。 操作： replaceAll(UnaryOperator): 根据UnaryOperator指定的计算规则重新设置List集合的所有元素。比如根据集合中元素的长度重新来作为新的集合。 sort(Comparator): 根据Comparator参数对List集合进行排序。源码中其实时调用了Arrays.sort()方法进行的排序，然后通过ListIterator迭代器进行设置集合元素。Arrays和ListIterator后续章节会进行讲解。比如根据集合中元素的长度重新排序。 添加： add(int, E):在指定位置插入指定的元素，该位置后面的元素索引全部加1。 addAll(int, Collection): 在指定位置插入指定的集合元素，增加后院元素的索引。 删除： remove(Object): 该方法在Collection中定义，List集合删除集合中的某个元素，判断集合中的元素是不是目标元素，是根据equals()方法进行判断的。 remove(int): 删除指定位置的元素。 修改： set(int, E): 将指定位置修改为指定的元素。 查询： get(int): 获得指定位置的元素。 indexOf(Object): 返回指定元素在List中第一次出现的位置索引。 lastIndexOf(Object): 返回指定元素在List中最后一次出现的位置索引。 subList(int,int): 获得从指定的开始位置到结束位置所有集合元素组成的子集合。 属性： listIterator()：获得列表元素的列表迭代器。 listIterator(int): 从列表中指定的位置开始，返回列表中元素的列表迭代器。 从上面可以看出，相比于Collection接口，List集合里增加了一些根据索引来操作集合元素的方法。 有个很有意思的问题：既然List接口是Collection接口的子接口，那么它当然拥有Collection接口里的全部方法，可是为何在List接口中又重新定义了size、isEmpty等方法呢？我们可以想像一下，当jvm发现几个类之间时继承关系，如果要使用顶级父类的方法，是不是还要一个类一个类的去调用呢？喝口咖啡，当然不会允许这样！为了避免一层层向父级调用，所以在子类中也会同样得定义父类拥有的方法。为了提高性能，java的全力以赴可见一斑。 参考资料： 《疯狂Java讲义》 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:28 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_ListIterator.html":{"url":"java/util/I_ListIterator.html","title":"I_ListIterator","keywords":"","body":"介绍 ListIterator接口是Iterator接口的子接口，所以拥有Iterator接口的所有方法。而它的作用也像它的名字一样简单直接，就是只能用于List及其子类的迭代器。 方法 这里只介绍其相对其父类Iterator独有的方法展开介绍。 查询： hasPrevious(): 是否拥有上一个元素。 previous(): 获得列表中的上一个元素。 nextIndex(): 获得下一个元素的坐标。 previousIndex(): 获得上一个元素的坐标。 修改： set(E): 将next()或者previous()返回的元素替换成指定的元素。 添加： add(E): 将指定的元素添加到列表中。添加的位置是next()返回的元素（如果有的话）之前，或者是previous()返回的元素（如果有的话）之后。 从上面方法中可以看出，ListIterator接口增加了从后向前遍历列表的功能，在I_List接口中我们讲到,List集合中，每一个元素都有其对应的坐标，所以这里也增加了获取坐标的方法。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 15:07:17 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/lang.html":{"url":"java/lang/lang.html","title":"lang","keywords":"","body":"lang © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 14:34:47 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/I_Iterable.html":{"url":"java/lang/I_Iterable.html","title":"I_Iterable","keywords":"","body":"I_Iterable 该接口是集合的顶级接口，正如jdk中注释的那样，实现了该接口，则可以进行for-each循环。 方法 iterator：该方法返回一个泛型类型的迭代器。 forEach：jdk1.8新增方法，对集合中每个元素遍历执行给定的操作。 spliterator：jdk1.8新增方法，该方法提供了一个可以并行遍历元素的迭代器，以适应现在cpu多核时代并行遍历的需求。更多相关介绍请查看文末参考资料。 方法探究 iterator方法 Iterable接口既然能让它的实现类能够进行for-each循环，那我们就拿ArrayList类来做个小示例（ArrayList是Iterable接口的子孙接口）： import java.util.*; public class Test{ public static void main(String[] args){ List list = new ArrayList(); list.add(\"a\"); list.add(\"b\"); list.add(\"c\"); for (String str : list) { System.out.println(str); } } } 编译运行后控制台输出： > javac Test.java > java Test a b c 那for-each到底是怎么进行循环的呢？我们通过javap命令对字节码进行反编译，看看能不能得出答案。 反编译后的字节码输出如下： public static void main(java.lang.String[]); Code: 0: new #2 // class java/util/ArrayList 3: dup 4: invokespecial #3 // Method java/util/ArrayList.\"\":()V 7: astore_1 8: aload_1 9: ldc #4 // String a 11: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 14: pop 15: aload_1 16: ldc #6 // String b 18: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 21: pop 22: aload_1 23: ldc #7 // String c 25: invokevirtual #5 // Method java/util/ArrayList.add:(Ljava/lang/Object;)Z 28: pop 29: aload_1 30: invokevirtual #8 // 注释1 Method java/util/ArrayList.iterator:()Ljava/util/Iterator; 33: astore_2 34: aload_2 35: invokeinterface #9, 1 // 注释2 InterfaceMethod java/util/Iterator.hasNext:()Z 40: ifeq 63 43: aload_2 44: invokeinterface #10, 1 // 注释3 InterfaceMethod java/util/Iterator.next:()Ljava/lang/Object; 49: checkcast #11 // class java/lang/String 52: astore_3 53: getstatic #12 // Field java/lang/System.out:Ljava/io/PrintStream; 56: aload_3 57: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 60: goto 34 63: return 果然，从字节码文件我标注的注释1、2、3可以看出，其实for-each最终还是被jvm通过调用Iterator迭代器实现的。 forEach方法 相信细心的小伙伴已经发现，forEach方法和I_Iterator中的forEachRemaining方法，二者都是对元素遍历执行给定的操作,那为何会有这2个方法呢？这不是多余吗？ 其实二者有所不同： forEach方法使用的是for-each循环遍历，而forEachRemaining方法使用迭代器Iterator遍历元素。 forEach方法是对Iterable中的所有元素进行遍历，可以多次调用；forEachRemaining方法第二次调用不会做任何操作，因为不会有下一个元素。 spliterator方法 我们看一下该方法的源码： default Spliterator spliterator() { return Spliterators.spliteratorUnknownSize(iterator(), 0); } 里面只有一行代码，调用了Spliterators的spliteratorUnknownSize方法，继续往下看： public static Spliterator spliteratorUnknownSize(Iterator iterator, int characteristics) { return new IteratorSpliterator<>(Objects.requireNonNull(iterator), characteristics); } 该方法通过有参构造器创建了一个IteratorSpliterator对象并返回，我们看这个构造器做了什么： public IteratorSpliterator(Iterator iterator, int characteristics) { this.collection = null; this.it = iterator; this.est = Long.MAX_VALUE; this.characteristics = characteristics & ~(Spliterator.SIZED | Spliterator.SUBSIZED); } 这个构造器其实就是使用给定的迭代器创建了Spliterator遍历器，并给定了初始大小。 而Spliterator是什么呢？Spliterator即splitable iterator可分割迭代器，它是一个接口，是Java为了并行遍历数据源中的元素而设计的迭代器，这个可以类比最早Java提供的顺序遍历迭代器Iterator，但一个是顺序遍历，一个是并行遍历。 Spliterator接口用到了Fork/Join设计思想，总得来说就是用递归的方式把并行的任务拆分成更小的子任务，然后把每个子任务的结果合并起来生成整体结果。这里对此不做深究，以后会专门对Fork-Join进行讨论。 参考资料： Java8里面的java.util.Spliterator接口有什么用？ © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-09 14:34:47 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/C_Class.html":{"url":"java/lang/C_Class.html","title":"C_Class","keywords":"","body":"C_Class Class类我理解为:java运行时类的类。 这个描述可能有点奇怪，可以暂时把它认为是描述java类的类。这也很好的体现了：万事万物皆对象。 方法 getComponentType():它是一个native方法. public native Class getComponentType(); 该方法的作用是返回一个数组的组件类型，如果该类不是数组，则返回null。那什么是数组的组件呢？就是数组元素！换句话说，就是返回数组中元素的类型。举例： String[] o = {\"aa\", \"bb\", \"cc\"}; System.out.println(o.getClass().getComponentType()); 控制台输出： class java.lang.String © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/reflect.html":{"url":"java/lang/reflect.html","title":"reflect","keywords":"","body":"reflect © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/reflect/C_Array.html":{"url":"java/lang/reflect/C_Array.html","title":"C_Array","keywords":"","body":"C_Array java数组类，里面定义了很多静态方法供程序员创建和使用数组。这些方法除了构造方法和获得实例的方法外，全都是native方法。 方法解读 newInstance(Class, int): 创建一个指定长度、类型的数组。 public static Object newInstance(Class componentType, int length) throws NegativeArraySizeException { return newArray(componentType, length); } private static native Object newArray(Class componentType, int length) throws NegativeArraySizeException; newInstance方法内部调用了原生native方法newArray，返回一个Object，该Object实质为数组类型(可以通过：返回值.getClass()方法查看所属类型)。 > newArray为本地原生方法，由虚拟机实现。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/C_System.html":{"url":"java/lang/C_System.html","title":"C_System","keywords":"","body":"C_System 方法 arraycopy(Object src, int srcPos, Object dest, int destPos, int length):复制数组。 具体讲解请点击M_arraycopy。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/system/M_arraycopy.html":{"url":"java/lang/system/M_arraycopy.html","title":"M_arraycopy","keywords":"","body":"介绍 arraycopy作用主要是复制数组，从其名字不是驼峰写法就可看出其历史之久远。数组的复制涉及到深复制和浅复制的问题，我认为比较重要，所以这里摘出来单独进行讲解。 方法定义 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 参数： src：源数组 srcPos：源数组中读取数据的起始位置 dest: 目标数组 destPos: 写入目标数组的其实位置 length: 要复制的长度 该方法为native方法，具体由java虚拟机实现。 方法作用： 从数组src中复制元素数组desc。也就是说，把原数组src[srcPos,srcPos+length-1]位置的元素，复制到dest的[destPos,destPos+length-1]位置上。 这是一种覆盖性的复制，即目标数组dest复制之前destPos,destPos+length-1位置上的数据会被覆盖。 深复制与浅复制 当数组为一维数组，且元素为基本类型或String类型时，属于深复制，即原数组与新数组的元素不会相互影响。 数组为多维数组，或一维数组中的元素为引用类型时，属于浅复制，原数组与新数组的元素引用指向同一个对象 参考资料： System.arraycopy()方法详解 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 16:51:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/knacks/knacks.html":{"url":"java/knacks/knacks.html","title":"技巧","keywords":"","body":"介绍 这里笔者会着重介绍一下日常开发代码中比较有意思的优化。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 16:06:29 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/knacks/if_else_decoupling.html":{"url":"java/knacks/if_else_decoupling.html","title":"if...else...解耦","keywords":"","body":"if...else...解耦 在spring的初始化bean中讲到，过深的if...else...条件判断使得代码变得可读性差、不易维护。 本文通过静态工厂+策略模式对if...else...实现解耦。 1.以初始化bean中发奖为例，首先定义一个接口： /** * @description: 发放奖励 * @author: yongmingcode */ public interface IHandOutPrize { void doHandOut(); } 2.定义发放现金奖励类： /** * @description: 发放现金奖励 * @author: yongmingcode */ @Service public class HandOutCash implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\" -------HandOutCash doHandOut-------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"cash\", this); } } 3.定义发放积分奖励类： /** * @description: 发放积分奖励 * @author: yongmingcode */ @Service public class HandOutPoint implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\"-------------HandOutPoint doHandOut -----------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"point\", this); } } 4.定义发放奖品的静态工厂类： /** * @description: 发放奖品的静态工厂 * @author: yongmingcode */ public class HandOutPrizeFactory { private static Map handOutPrizeMap = new HashMap(); public HandOutPrizeFactory() { } private static IHandOutPrize EMPTY = new EmptyHandOutPrize(); /** 注册 */ public static void registerHandOutPrize(String prizeType, IHandOutPrize handOutPrize){ handOutPrizeMap.put(prizeType, handOutPrize); } /** 获取 */ public static IHandOutPrize getHandOutPrize(String prizeType){ IHandOutPrize handOutPrize = handOutPrizeMap.get(prizeType); return handOutPrize == null ? EMPTY : handOutPrize; } private static class EmptyHandOutPrize implements IHandOutPrize{ public void doHandOut() { System.out.println(\" EmptyHandOutPrize \"); } } } 5.最后，写一个发放现金奖励类： /** * @description: if...else...解耦 * @author: yongmingcode */ public class IfElseDecoupling { public static void main(String[] args){ // 发放现金奖励 handOutPrize(\"cash\"); } private static void handOutPrize(String prizeType){ IHandOutPrize handOutPrize = HandOutPrizeFactory.getHandOutPrize(prizeType); handOutPrize.doHandOut(); } } 上面代码的解释： 定义了一个发放奖励的IHandOutPrize接口，该接口只有一个发放奖励的方法； HandOutCash、HandOutPoint是IHandOutPrize接口的两个实现类，同时实现了InitializingBean接口（该接口关介绍请移驾bean的初始化方法），并在afterPropertiesSet()方法中对当前类进行了注册； 通过静态工厂HandOutPrizeFactory类进行奖励的注册和获取； 在IfElseDecoupling类中进行发放奖励，如发放现金奖励只需要两行代码就够了。 总结： 优点：以上对if...else...形式代码进行了解耦重构，重构后的逻辑清晰、明了，如果新增一种奖品，只需要定义一个新的类即可，这样大大提高了代码的可读性和可维护性。 缺点：会增加很多类。 参考资料： 代码重构：用工厂+策略模式优化过多的if else代码块 我的Java设计模式-策略模式 Spring核心接口之InitializingBean © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-24 17:48:57 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"jvm/jvm.html":{"url":"jvm/jvm.html","title":"Jvm","keywords":"","body":"jvm © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 17:22:59 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"jvm/java_runtime_area.html":{"url":"jvm/java_runtime_area.html","title":"Java运行时数据区","keywords":"","body":"Java运行时数据区 Java虚拟机在执行java程序的过程中会把它管理的内存划分成若干个不同的数据区域。不同的区域有不同的作用，下面简单的介绍了各个区域的作用。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-12 17:32:06 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Spring源码解读 本节会对spring中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 17:18:18 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/bean/bean.html":{"url":"spring/bean/bean.html","title":"初始化bean","keywords":"","body":"伊始 五一、双十一、双十二之类的活动，常常需要根据用户获得的奖品，做不同的处理，这样代码中很可能就会有不少的判断。 比如活动中的奖品有：现金、积分、优惠券、BD奖品等，如果用户获得现金，我们就要做现金的逻辑处理，如果获得积分就做积分逻辑的处理。我们可能会这么做： if(\"cash\".equals(prize)){ System.out.println(\"给用户发现金！\"); }else if(\"points\".equals(prize)){ System.out.println(\"给用户发积分！\"); }else if(\"coupons\".equals(prize)){ System.out.println(\"给用户发优惠券！\"); }else if(\"aiqiyi\".equals(prize)){ System.out.println(\"给用户发爱奇艺会员！\"); } 如果奖品很多，就进行很多个判断。不难发现，这样的代码可读性差、不易维护。我们可以使用策略模式优化它，优化demo会在后面的文章中更新。 这里可以通过org.springframework.beans.factory.InitializingBean接口来实现。而InitializingBean接口就是spring中bean的初始化方法之一。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 17:18:14 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/bean/bean_initialization_method.html":{"url":"spring/bean/bean_initialization_method.html","title":"bean的初始换方法","keywords":"","body":"bean的初始换方法 Spring的Bean在初始化完成后及销毁之前，允许程序执行特定的操作。有一下三种方式定指定： 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 通过下面代码来验证： 配置文件spring-context.xml： 测试类： package com.init; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; /** * @author: yongmingcode * @create: 2020-04-22 17:43 */ public class TestInitializationBean implements InitializingBean, DisposableBean { public TestInitializationBean() { System.out.println(\"----------------------TestInitializationBean 构造方法执行------------------\"); } /** 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 */ public void afterPropertiesSet() throws Exception { System.out.println(\"TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行\"); } public void destroy() throws Exception { System.out.println(\"TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行\"); } /** 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 */ public void initMethod(){ System.out.println(\"TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行\"); } public void destroyMethod(){ System.out.println(\"TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行\"); } /** 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 */ @PostConstruct public void postConstruct(){ System.out.println(\"TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行\"); } @PreDestroy public void preDestroy(){ System.out.println(\"TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行\"); } public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\"); System.out.println(\"------------------------初始化完成------------------------------\"); context.close(); System.out.println(\"------------------------销毁完成------------------------------\"); } } 执行后控制台输出： 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.getSingleton()] DEBUG - Creating shared instance of singleton bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Creating instance of bean 'initAndDestroySeqBean' ----------------------TestInitializationBean 构造方法执行------------------ 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found init method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.postConstruct() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found destroy method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.preDestroy() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered init method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1ab9f17 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered destroy method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doCreateBean()] DEBUG - Eagerly caching bean 'initAndDestroySeqBean' to allow for resolving potential circular references 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeInitMethods()] DEBUG - Invoking init method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.postConstruct() TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeInitMethods()] DEBUG - Invoking afterPropertiesSet() on bean with name 'initAndDestroySeqBean' TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeCustomInitMethod()] DEBUG - Invoking init method 'initMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Finished creating instance of bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.initLifecycleProcessor()] DEBUG - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1ef3efa8] 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [PropertySourcesPropertyResolver.getProperty()] DEBUG - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source ------------------------初始化完成------------------------------ 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.doClose()] INFO - Closing org.springframework.context.support.ClassPathXmlApplicationContext@41f69e84: startup date [Wed Apr 22 18:06:25 CST 2020]; root of context hierarchy 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.destroySingletons()] DEBUG - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19b93fa8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,initAndDestroySeqBean]; root of factory hierarchy 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeDestroyMethods()] DEBUG - Invoking destroy method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.preDestroy() TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.destroy()] DEBUG - Invoking destroy() on bean with name 'initAndDestroySeqBean' TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.invokeCustomDestroyMethod()] DEBUG - Invoking destroy method 'destroyMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行 ------------------------销毁完成------------------------------ Disconnected from the target VM, address: '127.0.0.1:61729', transport: 'socket' 从执行结果可以看出： Bean在实例化的过程中：Constructor > @PostConstruct >InitializingBean > init-method Bean在销毁的过程中：@PreDestroy > DisposableBean > destroy-method 参考资料： Spring容器中的Bean几种初始化方法和销毁方法的先后顺序 spring的Bean初始化方法的2种方式 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 17:26:31 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "}}