{"./":{"url":"./","title":"介绍","keywords":"","body":"博客地址 技术博客——满月弓 【Gitbook】技术博客——满月弓 简 介 这是一个个人技术分享的网站。站中内容主要来源于博客、书籍以及笔者平时工作学习中知识点的总结。 以前自己的知识点都分门别类的记录在印象笔记和自己的个人主页，但最近服务器和域名都从百度云迁移了，而印象笔记更多的是自己使用，分享不便。我又发现，这是一个重新整理心中知识的机会，所以开启了这个技术分享的站点。 笔者一直认为，一件事物的兴盛，离不开无数贡献者的默默奉献。而知识，只有分享才会更有价值。笔者也愿意作为一名默默的贡献者，希望通过奉献自己的点点萤火，让知识传播与分享这把火燃的更旺！ 本站期望 志向立高远，学问做精细； 不积跬步，无以至千里。积累是人类永远谈不完的话题； 蚊子再小也是肉。记录的知识点不分主次，都需要认真咀嚼； 知其然，亦知其所以然。本站中的知识点，知道怎么用，更能知道为什么能这么用。 勘误与支持 由于笔者技术有限，编写时间仓促，文章中难免出现一些错误或者不准确的地方，恳请读者批评指正。如果您有更多的宝贵意见，可以再我的github上新建issue，笔者会尽快解答，期待得到您的真挚反馈。github地址： https://github.com/yongmingcode/yl_code © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 15:26:46 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/java.html":{"url":"java/java.html","title":"Java","keywords":"","body":"JDK源码解读 本节会对项目开发中的知识点进行总结以及对jdk 1.8中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 11:50:03 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/series.html":{"url":"java/series.html","title":"系列","keywords":"","body":"系列 每个系列定义一组java知识点，方便读者对各个知识点的整体进行把控，站得高，看的远。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-01 13:52:36 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/series/collection.html":{"url":"java/series/collection.html","title":"集合","keywords":"","body":"伊始 阳春三月，草长莺飞,我很享受校园风光（比如说情人坡上的美女~），也常常会和小伙伴一起去旁听一些学校比较有意思的公开课。学校的阶梯教室、讲师的尊尊教导，常常会梦里萦绕（谨此怀念过去许久的美好校园时光）。 为了方便操作，我们常常会将同一类型的元素放在一个阶梯教室里，哦，就是放在一起。在java中，可能你马上会想到数组，确实，数组是一个很好的解决方案。 数组有个特点，它的底层实现是在内存中寻找一块连续的座位，然后把具有相同特点的元素放在一起。可是公开课，常常人满为患，我和小伙伴常常找不到一块连续的座位，如果我们非要一块连续的座位，那么很可能就会被告知OOM异常。或许某次我们非常幸运，找到了连着的座位，可是后来又来了几个小伙伴要一起旁听课,为了体现基友情，我们又要重新找连在一起的座位，重新创建数组，这样就很费精力......所以，我们常常分开坐。 为了解决类似上面的问题，java提供了令人非常激动的保存对象工具——集合。集合解决了“在任意时刻，任意位置，创建任意数量对象”的问题。 在本节，我们会去探索java中集合的实现，学习集合的使用，分析涉及的算法，看看用到的设计模式，体会设计者的设计思路。 I_Iterator © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:40:12 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/util.html":{"url":"java/util/util.html","title":"util","keywords":"","body":"util java.util包存在rt.jar包中，该包提供了包含集合框架、遗留的集合类、事件模型、日期和时间实施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 jdk提供的工具类目录，存在于rt.jar包中。 rt.jar代表runtime JAR,包含引导类bootstrap classes，包含所有核心JavaJava基础类运行环境的已编译calss文件，更多相关介绍可以参考文末参考资料。 参考资料 Java / JDK / JRE中的rt.jar是什么？ 为什么重要？ 了解java .lang 包,java.util包等常用包 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:42:16 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/C_collections/C_collections.html":{"url":"java/util/C_collections/C_collections.html","title":"C_collections","keywords":"","body":"collections 这个类包含对集合进行操作的静态方法。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-03 23:22:10 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/C_collections/M_shuffle.html":{"url":"java/util/C_collections/M_shuffle.html","title":"M_shuffle方法解读","keywords":"","body":"伊始 有这么一个场景：有一个抽奖活动，需要对几种奖品随机发放。我们可以将不同的奖品类别放入List，然后调用shuffle方法打乱这个List中元素的顺序，然后get(0),即可获得随机的一个奖品。 ArrayList integerList = new ArrayList<>(); integerList.add(0); integerList.add(1); integerList.add(2); Collections.shuffle(integerList); // 控制台可能打印0、1、2中的任何一个 System.out.println(integerList.get(0)); 方法作用： shuffle(List list)：使用默认的随机源，随机排列指定的列表。所有排列将以近似相等的可能性发生。 shuffle(List list, Random rnd)：使用指定的随机源，随机排列指定的列表。假设随机性的来源是公平的，那么所有排列都会以相同的可能性发生。 方法原理 以下是jdk源码（1.8）： public static void shuffle(List list, Random rnd) { int size = list.size(); if (size 1; i--) swap(list, i-1, rnd.nextInt(i)); } else { Object arr[] = list.toArray(); // Shuffle array for (int i=size; i>1; i--) swap(arr, i-1, rnd.nextInt(i)); // Dump array back into list // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method ListIterator it = list.listIterator(); for (int i=0; i 上面代码先判断list的size是否小于SHUFFLE_THRESHOLD(5)或者实现RandomAccess接口，如果符合条件，则执行swap(List list, int i, int j)方法进行交换；如果不符合条件，则把list转为数组，数组执行swap(Object[] arr, int i, int j)（注意这里是另外一个swap()方法哦）方法进行交换，交换之后的数组循环转回List。 两个swap()方法： swap(Object[] arr, int i, int j) private static void swap(Object[] arr, int i, int j) { Object tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } 有三个参数： list：要交换元素的list。 i、j: 是两个要交换元素的下标 i: shuffle()方法中是从list的最后一个下标开始 j：列表中随机的一个下标 然后让i、j下标的元素进行交换。 swap(List list, int i, int j)方法： public static void swap(List list, int i, int j) { // instead of using a raw type here, it's possible to capture // the wildcard but it will require a call to a supplementary // private method final List l = list; l.set(i, l.set(j, l.get(i))); } i、j参数的含义和上面的swap(Object[] arr, int i, int j)方法含义相同，这两个swap方法都是使用了洗牌算法，在原数组中交换选择元素的位置。 但是swap(List list, int i, int j)方法中有一个需要注意的地方：final List l = list，这里为什么不直接用list，而是通过使用副本 l 进行操作呢？使用中间变量（副本）是为了规避泛型的缺点!不理解可以参考文末的参考文档。 两个疑问 到这里我产生了两个个疑问： shuffle方法中，判断条件为什么是size是否小于SHUFFLE_THRESHOLD(5)和实现RandomAccess接口？ 为什么符合条件就直接交换？不符合条件就转为数组再交换 对于SHUFFLE_THRESHOLD为什么是5，我大致查了一下，没有发现，如果有哪位仁兄知道，期待告知点这里，暂且全当是一个Lucky Number吧。 RandomAccess是一个空接口： public interface RandomAccess { } 也可以叫做标记接口。List类中支持快速访问的接口去实现它，也就是说，实现了该接口的类的数据结构应该是支持快速访问的。比如ArrayList类，随机访问一个元素(get(i))所花费的时间复杂度是O(1)。而LinkedList底层是链表实现，随机访问一个LinkedList中元素的时间复杂度是O(n)(最坏情况下)，所以LinkedList没有实现这个接口。 所以如果是LinkedList,可以转为Array再进行洗牌操作，是比较明智的。 标记接口：java开发者还是比较爱用的，通常会通过某个类是否实现了标记接口进行判断，如果实现了会进行一些特殊处理。jdk中中就比较常见，比如此时的shuffle方法中的RandomAccess接口，Spring在初始化bean实例时也会在initializeBean方法中判断要实例化的bean是否实现InitializingBean接口。 参考资料： 爲什麼Collections.swap複製輸入列表？ 为什么Collections.swap将目标列表分配给原始类型的变量？ Java 泛型，你了解类型擦除吗？ 三种洗牌 源码分析 Collections.shuffle()源码分析 ArrayList复杂度 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:40:11 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/util/I_iterator.html":{"url":"java/util/I_iterator.html","title":"I_Iterator","keywords":"","body":"I_Iterator Iterator顾名思义就是迭代器，这是自jdk1.2起就存在的专门用于集合的迭代器参数化接口。 用法举例 import java.util.ArrayList; import java.util.Iterator; public class Test { public static void main(String[] paramArrayOfString) { ArrayList arrayList = new ArrayList(); arrayList.add(\"a\"); arrayList.add(\"b\"); arrayList.add(\"c\"); Iterator iterator = arrayList.iterator(); while (iterator.hasNext()) { String str = iterator.next(); System.out.println(str); } } } 运行结果： > java Test a b c 上面定义了一个ArrayList，然后通过iterator对ArrayList进行了遍历。 接口方法 hasNext()：判断集合是否有下一个元素 next()：返回集合的下一个元素 remove()：移除集合中的某一个元素 forEachRemaining(Consumer action)：jdk1.8新增方法，对集合中剩余遍历的元素执行给定的操作（action） 迭代器Iterator对集合中的元素挨个操作，来实现循环遍历。所以Iterator更像是指针的一种抽象，通过不断的移动指针的指向，来遍历内存中的数据。但是指针和迭代器确实不是同一概念，这里只是为了更加形象的描述迭代器（二者有本质的不同：比如迭代器返回的是对象的引用而不是对象的值、指针能够指向函数而迭代器不，更多相关介绍可以参考文末参考资料。） 在jdk1.8之前：接口中的成员一律默认是 public 类型。接口中的变量默认被指定为public static final类型；接口中的方法默认时public abstract类型的抽象方法，而我们都知道抽象方法不能拥有方法体。 我们注意到remove和forEachRemaining方法都有方法体，这是为什么呢？jdk1.8对接口进行了增强，该版本针对接口新增了2大特性：1.static方法，2.default修饰符。我们注意到remove和forEachRemaining方法都是通过default修饰的，所以才使得它们能够拥有方法体。所以，jdk1.8中，如果要在接口中定义有方法体的方法，可以通过使用static或者是default关键字对方法进行修饰。更多相关介绍可以参考文末参考资料。 参考资料： 迭代器和指针的区别 Java8接口增强 深入理解Java的接口和抽象类 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:40:10 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/lang.html":{"url":"java/lang/lang.html","title":"lang","keywords":"","body":"lang © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:48:16 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/lang/I_Iterable.html":{"url":"java/lang/I_Iterable.html","title":"I_Iterable","keywords":"","body":"I_Iterable © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:48:16 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/knacks/knacks.html":{"url":"java/knacks/knacks.html","title":"技巧","keywords":"","body":"介绍 这里笔者会着重介绍一下日常开发代码中比较有意思的优化。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 22:08:56 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"java/knacks/if_else_decoupling.html":{"url":"java/knacks/if_else_decoupling.html","title":"if...else...解耦","keywords":"","body":"if...else...解耦 在spring的初始化bean中讲到，过深的if...else...条件判断使得代码变得可读性差、不易维护。 本文通过静态工厂+策略模式对if...else...实现解耦。 1.以初始化bean中发奖为例，首先定义一个接口： /** * @description: 发放奖励 * @author: yongmingcode */ public interface IHandOutPrize { void doHandOut(); } 2.定义发放现金奖励类： /** * @description: 发放现金奖励 * @author: yongmingcode */ @Service public class HandOutCash implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\" -------HandOutCash doHandOut-------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"cash\", this); } } 3.定义发放积分奖励类： /** * @description: 发放积分奖励 * @author: yongmingcode */ @Service public class HandOutPoint implements IHandOutPrize, InitializingBean { public void doHandOut() { System.out.println(\"-------------HandOutPoint doHandOut -----------\"); } /** 注册 */ public void afterPropertiesSet() throws Exception { HandOutPrizeFactory.registerHandOutPrize(\"point\", this); } } 4.定义发放奖品的静态工厂类： /** * @description: 发放奖品的静态工厂 * @author: yongmingcode */ public class HandOutPrizeFactory { private static Map handOutPrizeMap = new HashMap(); public HandOutPrizeFactory() { } private static IHandOutPrize EMPTY = new EmptyHandOutPrize(); /** 注册 */ public static void registerHandOutPrize(String prizeType, IHandOutPrize handOutPrize){ handOutPrizeMap.put(prizeType, handOutPrize); } /** 获取 */ public static IHandOutPrize getHandOutPrize(String prizeType){ IHandOutPrize handOutPrize = handOutPrizeMap.get(prizeType); return handOutPrize == null ? EMPTY : handOutPrize; } private static class EmptyHandOutPrize implements IHandOutPrize{ public void doHandOut() { System.out.println(\" EmptyHandOutPrize \"); } } } 5.最后，写一个发放现金奖励类： /** * @description: if...else...解耦 * @author: yongmingcode */ public class IfElseDecoupling { public static void main(String[] args){ // 发放现金奖励 handOutPrize(\"cash\"); } private static void handOutPrize(String prizeType){ IHandOutPrize handOutPrize = HandOutPrizeFactory.getHandOutPrize(prizeType); handOutPrize.doHandOut(); } } 上面代码的解释： 定义了一个发放奖励的IHandOutPrize接口，该接口只有一个发放奖励的方法； HandOutCash、HandOutPoint是IHandOutPrize接口的两个实现类，同时实现了InitializingBean接口（该接口关介绍请移驾bean的初始化方法），并在afterPropertiesSet()方法中对当前类进行了注册； 通过静态工厂HandOutPrizeFactory类进行奖励的注册和获取； 在IfElseDecoupling类中进行发放奖励，如发放现金奖励只需要两行代码就够了。 总结： 优点：以上对if...else...形式代码进行了解耦重构，重构后的逻辑清晰、明了，如果新增一种奖品，只需要定义一个新的类即可，这样大大提高了代码的可读性和可维护性。 缺点：会增加很多类。 参考资料： 代码重构：用工厂+策略模式优化过多的if else代码块 我的Java设计模式-策略模式 Spring核心接口之InitializingBean © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:34:13 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/spring.html":{"url":"spring/spring.html","title":"Spring","keywords":"","body":"Spring源码解读 本节会对spring中的部分源码进行解读，其中涉及到的知识点笔者会细心总结，不确定的也会查阅资料，尽力保证知识点的正确性。 解读方式 本着先使用，再了解原理的原则进行书写。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 22:42:56 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/bean/bean.html":{"url":"spring/bean/bean.html","title":"初始化bean","keywords":"","body":"伊始 五一、双十一、双十二之类的活动，常常需要根据用户获得的奖品，做不同的处理，这样代码中很可能就会有不少的判断。 比如活动中的奖品有：现金、积分、优惠券、BD奖品等，如果用户获得现金，我们就要做现金的逻辑处理，如果获得积分就做积分逻辑的处理。我们可能会这么做： if(\"cash\".equals(prize)){ System.out.println(\"给用户发现金！\"); }else if(\"points\".equals(prize)){ System.out.println(\"给用户发积分！\"); }else if(\"coupons\".equals(prize)){ System.out.println(\"给用户发优惠券！\"); }else if(\"aiqiyi\".equals(prize)){ System.out.println(\"给用户发爱奇艺会员！\"); } 如果奖品很多，就进行很多个判断。不难发现，这样的代码可读性差、不易维护。我们可以使用策略模式优化它，优化demo会在后面的文章中更新。 这里可以通过org.springframework.beans.factory.InitializingBean接口来实现。而InitializingBean接口就是spring中bean的初始化方法之一。 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-04-23 22:08:56 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "},"spring/bean/bean_initialization_method.html":{"url":"spring/bean/bean_initialization_method.html","title":"bean的初始换方法","keywords":"","body":"bean的初始换方法 Spring的Bean在初始化完成后及销毁之前，允许程序执行特定的操作。有一下三种方式定指定： 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 通过下面代码来验证： 配置文件spring-context.xml： 测试类： package com.init; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean; import org.springframework.context.support.ClassPathXmlApplicationContext; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; /** * @author: yongmingcode * @create: 2020-04-22 17:43 */ public class TestInitializationBean implements InitializingBean, DisposableBean { public TestInitializationBean() { System.out.println(\"----------------------TestInitializationBean 构造方法执行------------------\"); } /** 实现InitializingBean/DisposableBean接口来指定初始化之后/销毁之前的操作方法 */ public void afterPropertiesSet() throws Exception { System.out.println(\"TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行\"); } public void destroy() throws Exception { System.out.println(\"TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行\"); } /** 通过配置文件的标签中init-method/destroy-method属性指定初始化之后/销毁之前调用的操作方法 */ public void initMethod(){ System.out.println(\"TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行\"); } public void destroyMethod(){ System.out.println(\"TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行\"); } /** 在指定方法上加上@PostConstruct或@PreDestroy注解来指定该方法是在初始化之后还是销毁之前调用 */ @PostConstruct public void postConstruct(){ System.out.println(\"TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行\"); } @PreDestroy public void preDestroy(){ System.out.println(\"TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行\"); } public static void main(String[] args) { ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"spring-context.xml\"); System.out.println(\"------------------------初始化完成------------------------------\"); context.close(); System.out.println(\"------------------------销毁完成------------------------------\"); } } 执行后控制台输出： 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.getSingleton()] DEBUG - Creating shared instance of singleton bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Creating instance of bean 'initAndDestroySeqBean' ----------------------TestInitializationBean 构造方法执行------------------ 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found init method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.postConstruct() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.doWith()] DEBUG - Found destroy method on class [com.init.TestInitializationBean]: public void com.init.TestInitializationBean.preDestroy() 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered init method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a1ab9f17 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.checkConfigMembers()] DEBUG - Registered destroy method on class [com.init.TestInitializationBean]: org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement@a27dd7d7 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doCreateBean()] DEBUG - Eagerly caching bean 'initAndDestroySeqBean' to allow for resolving potential circular references 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeInitMethods()] DEBUG - Invoking init method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.postConstruct() TestInitializationBean postConstruct ,表示@PostConstruct注解初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeInitMethods()] DEBUG - Invoking afterPropertiesSet() on bean with name 'initAndDestroySeqBean' TestInitializationBean afterPropertiesSet ,表示实现InitializingBean接口初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.invokeCustomInitMethod()] DEBUG - Invoking init method 'initMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean initMethod ,表示配置init-method属性初始化之后执行 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.createBean()] DEBUG - Finished creating instance of bean 'initAndDestroySeqBean' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory' 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.initLifecycleProcessor()] DEBUG - Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1ef3efa8] 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [PropertySourcesPropertyResolver.getProperty()] DEBUG - Could not find key 'spring.liveBeansView.mbeanDomain' in any property source ------------------------初始化完成------------------------------ 2020-04-22 18:06:26 [main] [ClassPathXmlApplicationContext.doClose()] INFO - Closing org.springframework.context.support.ClassPathXmlApplicationContext@41f69e84: startup date [Wed Apr 22 18:06:25 CST 2020]; root of context hierarchy 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.doGetBean()] DEBUG - Returning cached instance of singleton bean 'lifecycleProcessor' 2020-04-22 18:06:26 [main] [DefaultListableBeanFactory.destroySingletons()] DEBUG - Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@19b93fa8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,initAndDestroySeqBean]; root of factory hierarchy 2020-04-22 18:06:26 [main] [CommonAnnotationBeanPostProcessor.invokeDestroyMethods()] DEBUG - Invoking destroy method on bean 'initAndDestroySeqBean': public void com.init.TestInitializationBean.preDestroy() TestInitializationBean preDestroy ,表示@PreDestroy注解销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.destroy()] DEBUG - Invoking destroy() on bean with name 'initAndDestroySeqBean' TestInitializationBean destroy ,表示实现DisposableBean接口销毁之前执行 2020-04-22 18:06:26 [main] [DisposableBeanAdapter.invokeCustomDestroyMethod()] DEBUG - Invoking destroy method 'destroyMethod' on bean with name 'initAndDestroySeqBean' TestInitializationBean destroyMethod ,表示配置destroy-method属性销毁之前执行 ------------------------销毁完成------------------------------ Disconnected from the target VM, address: '127.0.0.1:61729', transport: 'socket' 从执行结果可以看出： Bean在实例化的过程中：Constructor > @PostConstruct >InitializingBean > init-method Bean在销毁的过程中：@PreDestroy > DisposableBean > destroy-method 参考资料： Spring容器中的Bean几种初始化方法和销毁方法的先后顺序 spring的Bean初始化方法的2种方式 © yongmingcode all right reserved，powered by Gitbook文件修订时间： 2020-05-04 16:34:25 var gitalk = new Gitalk({ \"clientID\": \"a5507922d082a1660ea3\", \"clientSecret\": \"bc5403682cf03d556504f444bc1df0ef0b7f853a\", \"repo\": \"yl_code\", \"owner\": \"yongmingcode\", \"admin\": [\"yongmingcode\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); "}}